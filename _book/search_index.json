[["index.html", "Digital Soil Mineralogy with R Preface Prerequisites Code Conventions What to expect About the authors Acknowledgments", " Digital Soil Mineralogy with R Benjamin Butler and Steve Hillier 2021-06-25 Preface Digital Soil Mineralogy relates to the data-driven analysis of soil X-ray powder diffraction (XRPD) data. Such data are considered to be precise digital signatures of a given soils mineralogy, within which is all of the information required to identify and quantify the various mineral components within these complex mixtures. In recent years various methods for Digital Soil Mineralogy have been developed and published in peer-reviewed literature. These methods include the use of supervised and unsupervised machine learning to predict and interpret soil properties from XRPD data, the application of novel multivariate statistical methods, and automated approaches for mineral quantification. Each chapter in this documentation will detail one such method, providing code and data for reproducible examples that can be adapted by readers for their own projects/research. Whilst all data and methods presented herein relate to soil samples, the methods can be considered transferable to all aspects of environmental mineralogy and beyond! Prerequisites To run the examples provided throughout this document, it is recommended that you have R and RStudio installed on your machine. Once thats set up, then additional extensions (packages) required along the way can be installed and loaded. R and its extensions are designed to be multi-platform so all material presented here should work on Windows, Mac, or Linux. The only package needed from the very start of the document is powdR, and subsequent packages will be introduced in later chapters. To install powdR, use: install.packages(&quot;powdR&quot;) Code Conventions This document contains many chunks of R code that provide reproducible examples that can be copied and pasted to run on your own computer, for instance: #Summarise a vector of integers 1 to 10 summary(1:10) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 3.25 5.50 5.50 7.75 10.00 Text outputs associated with R code are denoted by two hashes (##) by default, as you can see from the example above. This is for your convenience when you want to copy and run the code (the text output will be ignored since it is commented out). Inline code and filenames are formatted in a typewriter font (e.g., summary(1:10)). Function names are followed by parentheses (e.g., mean(1:10)). What to expect This document is divided into chapters that each detail specific aspects of Digital Soil Mineralogy. To start with, the basics of handling XRPD data in R are introduced, which progresses to more advanced manipulation of such data that cannot be realised with proprietary XRPD software. Subsequently, specific examples of methods for Digital Soil Mineralogy are provided that include high throughput quantitative analysis, data mining, and cluster analysis. As such, the documentation is separated into the following chapters: Chapter 1: Loading and handling XRPD data in R Chapter 2: Quantitative analysis of XRPD data using full pattern summation Chapter 3: The use of machine learning to predict and interpret soil properties from XRPD data Chapter 4: The application of cluster analysis to identify discrete groups of soils based on mineralogy Chapter 5: Identifying soils analogues for Martian mineralogy based on XRPD data Each chapter contains reproducible R code along with written explanations and video tutorials. With exception to Chapter 1, all chapters are standalone so there is no need to read everything! About the authors Benjamin Butler is a Digital Mineralogist at the James Hutton Institute, Aberdeen, UK. His interests centre around the use of XRPD to characterise the mineral composition of environmental mixtures such as soils, construction and demolition waste, and sea ice. As an active R user he has authored the powdR package that provides a range of methods for quantitative analysis of XRPD data using full pattern summation. Aside from dealing with data, he is involved in regular soil surveys on forestry land across Scotland, allowing him to observe soils from the digging to the databases. Steve Hillier is a Soil Mineralogist at the James Hutton Institute, Aberdeen, UK Acknowledgments The research that comprises the bulk of this material, and the time required to create this material was kindly funded by the Macaulay Development Trust. The support of the Scottish Government. The support of the Scottish Governments Rural and Environment Science and Analytical Services Division (RESAS) is also gratefully acknowledged. "],["intro.html", "Chapter 1 Working with XRPD data in R 1.1 The basic form of XRPD data 1.2 Loading XRPD data 1.3 Plotting XRPD data 1.4 Manipulating XRPD data", " Chapter 1 Working with XRPD data in R Benjamin Butler At this stage it is assumed that you have R and RStudio installed on your computer and have installed the powdR package using install.packages(\"powdR\"). For brief introductions to R, the RStudio website has links to useful material. One aspect worth noting is that any R function used throughout this document will have additional help associated with it that can be accessed using ?. For example, to access help on the mean() function, use ?mean. This chapter will work through: The basic form of XRPD data Loading XRPD data in R Plotting XRPD data Manipulating XRPD data 1.1 The basic form of XRPD data In its most basic form, XRPD data (a diffractogram) is simply comprised of an x-axis (2\\(\\theta\\)) and y-axis (counts). The following figure shows a diffratogram for a soil from north east Scotland. Figure 1.1: A diffractogram of a soil developed from Granite in north east Scotland Each mineral contributing to the observed diffractogram contributes peaks at specific locations along the x-axis, each with chracteristic relative intensities to one-another that are defined by the crystal structure and chemistry. Each mineral can therefore be considered to have a unique signature. For quartz, an omnipresent mineral in the worlds soils, this signature is relatively simple: Figure 1.2: A diffractogram of quartz whereas other soil minerals such as K-feldspar have very different peak positions and relative intensities: Figure 1.3: A diffractogram of K-feldspar (orthoclase) In any given diffractogram there can be a number of different minerals contributing their unique signature to the observed pattern, which ends up simply being the sum of these signatures each scaled by different amounts (scaling factors). These scaling factors are inherently related to a given minerals concentration within the mixture based on the defined diffracting power of each mineral, known as Reference Intensity Ratios (see Chapter 2). Together these principles make XRPD the most widely used analytical technique for qualitative and quantitative soil mineralogy. Most XRPD data adhere to this basic form, but often vary in the monochromatic wavelength used and instrumental parameters. 1.2 Loading XRPD data In order to work with XRPD data in R, it first needs to be loaded. XRPD data come in all sorts of proprietary formats (e.g. .raw, .dat and .xrdml), which can make this initial stage of loading data more complicated than it needs to be. In its most basic form, XRPD data is simply comprised of an x-axis (2\\(\\theta\\)) and y-axis (counts), and all XRPD data loaded into R throughout this documentation will take this XY form. There are 2 ways of loading proprietary XRPD data into R. 1.2.1 Option 1: PowDLL The free software PowDLL written by Nikoloas Kourkoumelis, offers excellent for the conversion of different XRPD file types. PowDLL can import and export a large range of XRPD file types including .xy files that are most easily loaded into R. These .xy files are an ASCII format that simply comprises the two variables (2\\(\\theta\\) and counts) separated by a space. The following video from Phys Whiz on YouTube illustrates use of powDLL to create the .xy files that we seek to use. Once you have your .xy files, they can be loaded into R using the read_xy() function from the powdR package. The following reproducible example uses files that are stored within powdR and were recorded on a Siemens D5000 using Co-K\\(\\alpha\\) radiation. library(powdR) #Extract the path of the file from the powdR package file &lt;- system.file(&quot;extdata/D5000/xy/D5000_1.xy&quot;, package = &quot;powdR&quot;) #Load the file as an object called xy1 xy1 &lt;- read_xy(file) #Explore the xy data summary(xy1) ## tth counts ## Min. : 2.00 Min. : 70.0 ## 1st Qu.:20.25 1st Qu.: 145.0 ## Median :38.50 Median : 236.0 ## Mean :38.50 Mean : 292.9 ## 3rd Qu.:56.75 3rd Qu.: 342.0 ## Max. :75.00 Max. :6532.0 #check the class of xy data class(xy1) ## [1] &quot;XY&quot; &quot;data.frame&quot; Notice how the class of xy1 is both XY and data.frame. This means that various additional methods for each of these types of object classes can be used to explore and analyse the data. These methods can be viewed using: methods(class = &quot;XY&quot;) ## [1] align_xy interpolate plot ## see &#39;?methods&#39; for accessing help and source code which shows how functions align_xy(), interpolate() and plot() all have methods for XY class objects. Help on each of these can be sourced using ?align_xy.XY, ?interpolate.XY and ?plot.XY, respectively. When calling these functions it is not necessary to specify the .XY suffix because R will recognise the class and call the relevant method. 1.2.2 Option 2: Loading directly into R Alternatively to PowDLL, the extract_xy() function in the powdR package can extract the XY data from a wide range of proprietary XRPD files straight into R via the xylib C++ library implemented behind the scenes in the rxylib package (Kreutzer and Johannes Friedrich 2020). #Extract the path of the file from the powdR package file &lt;- system.file(&quot;extdata/D5000/RAW/D5000_1.RAW&quot;, package = &quot;powdR&quot;) #Load the file as an object called xy2 xy2 &lt;- extract_xy(file) ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected #Summarise the xy data summary(xy2) ## tth counts ## Min. : 2.00 Min. : 70.0 ## 1st Qu.:20.25 1st Qu.: 145.0 ## Median :38.50 Median : 236.0 ## Mean :38.50 Mean : 292.9 ## 3rd Qu.:56.75 3rd Qu.: 342.0 ## Max. :75.00 Max. :6532.0 #Check the class of xy2 class(xy2) ## [1] &quot;XY&quot; &quot;data.frame&quot; A word of warning with extract_xy() is that it does not work with all proprietary file types. In particular you may experience problems with Bruker .raw files, in which case the use of PowDLL outlined above is recommended instead. 1.2.3 Loading multiple files The two approaches for loading XRPD data outlined above can also be used to load any number of files into R at once. read_xy() and extract_xy() will recognise cases where more than one file path is supplied and therefore load the files into a multiXY object. 1.2.3.1 read_xy() There are five .xy files stored within a directory of the powdR package that can be loaded into a multiXY object via: paths1 &lt;- dir(system.file(&quot;extdata/D5000/xy&quot;, package = &quot;powdR&quot;), full.names = TRUE) #Now read all files in the directory xy_list1 &lt;- read_xy(paths1) #Check the class of xy_list1 class(xy_list1) ## [1] &quot;multiXY&quot; &quot;list&quot; The resulting multiXY object is a list of XY objects, with each XY object being a data frame comprised of the \\(2\\theta\\) and count intensities of the XRPD data. #Check the class of each item within the multiXY object lapply(xy_list1, class) ## $D5000_1 ## [1] &quot;XY&quot; &quot;data.frame&quot; ## ## $D5000_2 ## [1] &quot;XY&quot; &quot;data.frame&quot; ## ## $D5000_3 ## [1] &quot;XY&quot; &quot;data.frame&quot; ## ## $D5000_4 ## [1] &quot;XY&quot; &quot;data.frame&quot; ## ## $D5000_5 ## [1] &quot;XY&quot; &quot;data.frame&quot; Each sample within the list can be accessed using the $ symbol. For example: #Summarise the data within the first sample: summary(xy_list1$D5000_1) ## tth counts ## Min. : 2.00 Min. : 70.0 ## 1st Qu.:20.25 1st Qu.: 145.0 ## Median :38.50 Median : 236.0 ## Mean :38.50 Mean : 292.9 ## 3rd Qu.:56.75 3rd Qu.: 342.0 ## Max. :75.00 Max. :6532.0 Alternatively, the same item within xy_list1 could be accessed using xy_list1[[1]]. In the same way the XY class objects have methods associated with them, there are a number of different methods for multiXY objects: methods(class = &quot;multiXY&quot;) ## [1] align_xy interpolate multi_xy_to_df plot ## see &#39;?methods&#39; for accessing help and source code which include align_xy(), interpolate(), multi_xy_to_df() and plot that are all detailed in subsequent sections. 1.2.3.2 extract_xy() In addition to the five .xy files loaded above, there are also five .RAW files stored within a separate directory of powdR, that can be loaded in a similar fashion using extract_xy(): paths2 &lt;- dir(system.file(&quot;extdata/D5000/RAW&quot;, package = &quot;powdR&quot;), full.names = TRUE) #Now read all files in the directory xy_list2 &lt;- extract_xy(paths2) ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected #Find out what the xy_list2 is class(xy_list2) ## [1] &quot;multiXY&quot; &quot;list&quot; which yields xy_list2 that is identical to xy_list1: all.equal(xy_list1, xy_list2) ## [1] TRUE 1.3 Plotting XRPD data The powdR package contains plot() methods for both XY and multiXY objects (see ?plot.XY and plot.multiXY). 1.3.1 Plotting XY objects An XY object can be plotted by: plot(xy1, wavelength = &quot;Co&quot;, interactive = FALSE) Figure 1.4: An example figure created using the plot method for an XY object. where wavelength = \"Co\" is required so that d-spacings can be computed and displayed when interactive = TRUE. 1.3.2 Plotting multiXY objects Often its useful to plot more than one pattern at the same time, which can be achieved by plotting a multiXY object: plot(xy_list1, wavelength = &quot;Co&quot;) Figure 1.5: An example figure created using the plot method for a multiXY object. As above, adding interactive = TRUE to the function call will produce an interactive plot. In addition, plotting of XY and multiXY objects also allows you to alter the x-axis limits and normalise the count intensities for easier comparison of specific peaks: plot(xy_list1, wavelength = &quot;Co&quot;, xlim = c(30, 32), normalise = TRUE) Figure 1.6: An example figure created using the plot method for an XY object with normalised count intensities and a restrict x-axis. 1.3.3 Modifying plots with ggplot2 All plots shown so far are produced behind the scenes using the ggplot2 package, which will already be present on your machine if you have installed powdR. This means that it is possible to modify the plots in different ways by adding subsequent ggplot2 layers, each separated by +. For example, its possible to add points of the quartz peak intensities extracted from a crystal structure database using geom_point(), and then add a title using ggtitle(), followed by changing the theme using theme_bw(). #Define the relative intensities of quartz peaks quartz &lt;- data.frame(&quot;tth&quot; = c(24.22, 30.99, 42.61, 46.12, 47.06, 49.62, 53.62, 58.86, 64.60, 65.18, 70.79, 73.68), &quot;intensity&quot; = c(0.20, 1.00, 0.06, 0.06, 0.03, 0.05, 0.03, 0.11, 0.03, 0.01, 0.07, 0.03)) #Load the ggplot2 package library(ggplot2) #Create a plot called p1 p1 &lt;- plot(xy1, wav = &quot;Co&quot;, normalise = TRUE) + geom_point(data = quartz, aes(x = tth, y = intensity), size = 5, shape = 21, colour = &quot;red&quot;) + ggtitle(&quot;A soil with quartz peaks identified&quot;) + theme_bw() p1 Figure 1.7: A quartz diffractogram with the locations and relative intensities of the quartz peaks identified. Further help on ggplot2 is provided in Hadley Wickhams excellent documentation on data visualization. Plots produced using ggplot2 are static and can be exported as high quality images or pdfs. In some cases it can also be useful to produce an interactive plot, especially when minor features of XRPD data require inspection. For most plots derived from ggplot2, the ggplotly() function from the plotly package can be used to create such interactive plots that will load either in RStudio or your web browser: library(plotly) ggplotly(p1) 1.4 Manipulating XRPD data At this stage we have loaded XRPD data into R and to produced plots to visualise both single and multiple patterns. Loading into R opens up almost limitless capabilities for analysing and manipulating the data via the R language and the thousands of open source packages that enhance its functionality. Here some common forms of data manipulation will be introduced: Subsetting Transformations Interpolation Alignment Background fitting Converting to data frames \\(2\\theta\\) transformation 1.4.1 Subsetting XRPD data Quite often the analysis of XRPD data may be applied to a reduced \\(2\\theta\\) range to that measured on the diffractometer. This can readily be achieved in R, and offers an opportunity to introduce how functions can be written. By summarising xy1 we can see that the \\(2\\theta\\) column has a minimum of 2 and a maximum of 75 degrees. summary(xy1) ## tth counts ## Min. : 2.00 Min. : 70.0 ## 1st Qu.:20.25 1st Qu.: 145.0 ## Median :38.50 Median : 236.0 ## Mean :38.50 Mean : 292.9 ## 3rd Qu.:56.75 3rd Qu.: 342.0 ## Max. :75.00 Max. :6532.0 If we wanted to reduce this to the range of 1060 \\(^\\circ 2\\theta\\) then we have a couple of options. First we could extract the relevant data directly using the [,] notation for a data frame, where values before the comma represent rows and values after the comma represent columns: xy1_sub &lt;- xy1[xy1$tth &gt;= 10 &amp; xy2$tth &lt;= 60, ] summary(xy1_sub) ## tth counts ## Min. :10.0 Min. : 93.0 ## 1st Qu.:22.5 1st Qu.: 174.0 ## Median :35.0 Median : 256.0 ## Mean :35.0 Mean : 308.2 ## 3rd Qu.:47.5 3rd Qu.: 345.0 ## Max. :60.0 Max. :6532.0 This first option is quite simple, but if we wanted to apply it to a list of patterns then turning it into a function would be preferable. Here we will create a function called subset_xrpd(), which will be designed for data frames of XRPD data: subset_xrpd &lt;- function (x, xmin, xmax) { x &lt;- x[x[[1]] &gt;= xmin &amp; x[[1]] &lt;= xmax, ] return(x) } Note that x[[1]] is extracting the first column of the XRPD data, whilst in the first example x$tth was used for the same purpose. Use of x[[1]] instead is a little more robust because it will work even if the column names are changed. Now that we have created a function to subset the data, it is very easy to apply it to any number of patterns using lapply(): xy_list1_sub &lt;- lapply(xy_list1, subset_xrpd, xmin = 10, xmax = 60) #Similarly we can summarise the data in the list again lapply(xy_list1_sub, summary) ## $D5000_1 ## tth counts ## Min. :10.0 Min. : 93.0 ## 1st Qu.:22.5 1st Qu.: 174.0 ## Median :35.0 Median : 256.0 ## Mean :35.0 Mean : 308.2 ## 3rd Qu.:47.5 3rd Qu.: 345.0 ## Max. :60.0 Max. :6532.0 ## ## $D5000_2 ## tth counts ## Min. :10.0 Min. : 176 ## 1st Qu.:22.5 1st Qu.: 361 ## Median :35.0 Median : 469 ## Mean :35.0 Mean : 557 ## 3rd Qu.:47.5 3rd Qu.: 730 ## Max. :60.0 Max. :2094 ## ## $D5000_3 ## tth counts ## Min. :10.0 Min. : 74.0 ## 1st Qu.:22.5 1st Qu.: 154.0 ## Median :35.0 Median : 193.0 ## Mean :35.0 Mean : 240.6 ## 3rd Qu.:47.5 3rd Qu.: 251.0 ## Max. :60.0 Max. :5150.0 ## ## $D5000_4 ## tth counts ## Min. :10.0 Min. : 64 ## 1st Qu.:22.5 1st Qu.: 133 ## Median :35.0 Median : 168 ## Mean :35.0 Mean : 223 ## 3rd Qu.:47.5 3rd Qu.: 216 ## Max. :60.0 Max. :7110 ## ## $D5000_5 ## tth counts ## Min. :10.0 Min. : 51.0 ## 1st Qu.:22.5 1st Qu.: 102.0 ## Median :35.0 Median : 133.0 ## Mean :35.0 Mean : 202.3 ## 3rd Qu.:47.5 3rd Qu.: 183.0 ## Max. :60.0 Max. :6837.0 1.4.2 Transformations As will be introduced in subsequent chapters, log and root transforms of the count intensities of XRPD data can be useful when applying data mining or machine learning methods. Following the same principles as outlined for subsetting, these transformations can be applied to any number of patterns in just a few lines of code: #Create a function for log-transforming counts log_xrpd &lt;- function (x) { x[[2]] &lt;- log10(x[[2]]) return(x) } #apply the function to a list of XRPD data xy_list1_log &lt;- lapply(xy_list1, log_xrpd) #Plot the transformed data plot(as_multi_xy(xy_list1_log), wavelength = &quot;Cu&quot;) Figure 1.8: Log transformed XRPD data. 1.4.3 Interpolation Sometimes XRPD patterns within a given data set may contain a number of different \\(2\\theta\\) axes due to the measurements being carried out on different instruments or on the same instrument but with a different set-up. Direct comparison of such data requires that they are interpolated onto the same \\(2\\theta\\) axis. Here a data set containing 3 samples with different \\(2\\theta\\) axes will be created using the soils and rockjock_mixtures data that are pre-loaded within the powdR package: two_instruments &lt;- as_multi_xy(list(&quot;a&quot; = soils$granite, &quot;b&quot; = rockjock_mixtures$Mix2)) plot(two_instruments, wavelength = &quot;Cu&quot;, normalise = TRUE) Figure 1.9: Diffractograms from two different instruments. In this example, the data within the two_instruments list will be interpolated onto an artificial \\(2\\theta\\) axis called new_tth, which ranges from 10 to 60 \\(^\\circ 2\\theta\\) with a resolution of 0.02: new_tth &lt;- seq(10, 60, 0.02) two_instruments_int &lt;- interpolate(two_instruments, new_tth) plot(two_instruments_int, wavelength = &quot;Cu&quot;, normalise = TRUE) Figure 1.10: Interpolated diffractograms from two different instruments. 1.4.4 Alignment Peak positions in XRPD data commonly shift in response to small variations in specimen height in the instrument. Even seemingly small misalignments between peaks can hinder the analysis of XRPD data (Butler et al. 2019). One approach to deal with such peak shifts is to use a mineral with essentially invariant peak positions as an internal standard (e.g. the common mineral quartz), resulting in well aligned data by adding or subtracting a fixed value to the \\(2\\theta\\) axis. The powdR package contains functionality for aligning single or multiple patterns using the align_xy() function. In the following examples, samples will be aligned to a pure quartz pattern that will be loaded from the powdR package using read_xy() #Extract the location of the quartz xy file quartz_file &lt;- system.file(&quot;extdata/minerals/quartz.xy&quot;, package = &quot;powdR&quot;) #load the file quartz &lt;- read_xy(quartz_file) #Plot the main quartz peak for pure quartz and a sandstone-derived soil plot(as_multi_xy(list(&quot;quartz&quot; = quartz, &quot;sandstone&quot; = soils$sandstone)), wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26, 27)) Figure 1.11: Unaligned diffractograms. As shown in the figure above, the main quartz peaks of these two diffraction patterns do not align. This can be corrected using align_xy(): #Align the sandstone soil to the quartz pattern sandstone_aligned &lt;- align_xy(soils$sandstone, std = quartz, xmin = 10, xmax = 60, xshift = 0.2) #Plot the main quartz peak for pure quartz and a sandstone-derived soil plot(as_multi_xy(list(&quot;quartz&quot; = quartz, &quot;sandstone aligned&quot; = sandstone_aligned)), wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26, 27)) Figure 1.12: Aligned diffractograms. In cases where multiple patterns require alignment to a given standard, align_xy() can also be applied to multiXY objects: #Plot the unaligned soils data to show misalignments plot(soils, wav = &quot;Cu&quot;, xlim = c(26, 27), normalise = TRUE) Figure 1.13: Unaligned diffractograms in a multiXY object. #Align the sandstone soil to the quartz pattern soils_aligned &lt;- align_xy(soils, std = quartz, xmin = 10, xmax = 60, xshift = 0.2) #Plot the main quartz peak for pure quartz and a sandstone-derived soil plot(soils_aligned, wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26, 27)) Figure 1.14: Aligned diffractograms in a multiXY object. 1.4.5 Background fitting Sometimes it is beneficial to fit and subtract the background from XRPD data. To achieve this, the powdR package includes the bkg() function which uses the peak filling method implemented in the baseline package (Liland, Almøy, and Mevik 2010). The fitting provided by the bkg() function uses four adjustable parameters that each have pre-loaded defaults (see ?bkg): #Fit a background to the sandstone-derived soil granite_bkg &lt;- bkg(soils$granite) #summarise the resulting data summary(granite_bkg) ## Length Class Mode ## tth 1693 -none- numeric ## counts 1693 -none- numeric ## background 1693 -none- numeric #Plot the data and add a square root transform to aid interpretation plot(granite_bkg) + scale_y_sqrt() Figure 1.15: Fitting a background to a soil diffractogram. The y-axis is square root transformed to aid interpretation. It is then simple to derive a background-subtracted XY object: #Fit a background to the sandstone-derived soil sandstone_bkg_sub &lt;- as_xy(data.frame(&quot;tth&quot; = granite_bkg$tth, &quot;counts&quot; = granite_bkg$counts - granite_bkg$background)) plot(sandstone_bkg_sub, wavelength = &quot;Cu&quot;) Figure 1.16: Background subtracted diffractogram. Sometimes the default values for the adjustable parameters (see ?bkg) are not appropriate, and in such cases tuning of the parameters can be an iterative process. To help with this, there is a background fitting Shiny app that can be loaded from the powdR package using run_bkg(). This app will load in your default web browser and allows for the four adjustable parameters to be tuned to a given sample that is loaded into the app in .xy format. 1.4.6 Converting to data frames multiXY objects can be converted to data frames using the multi_xy_to_df() function. When using this function, all samples within the multiXY object must be on the same \\(2\\theta\\) axis, which can be ensured using the interpolate() function outlined above. #Convert xy_list1 to a dataframe xy_df1 &lt;- multi_xy_to_df(xy_list1, tth = TRUE) #Show the first 6 rows of the derived data frame head(xy_df1) ## tth D5000_1 D5000_2 D5000_3 D5000_4 D5000_5 ## 1 2.00 2230 2334 2381 2323 2169 ## 2 2.02 2012 2222 2297 2128 2021 ## 3 2.04 1950 2031 2211 2056 1929 ## 4 2.06 1828 1972 2077 1918 1823 ## 5 2.08 1715 1896 2000 1861 1757 ## 6 2.10 1603 1701 1868 1799 1673 In cases where the \\(2\\theta\\) column is not required, the use of tth = FALSE in the function call will result in only the count intensities being included in the output. 1.4.7 \\(2\\theta\\) transformation Laboratory XRPD data are usually collected using either Cu or Co X-ray tubes, which each have characteristic K\\(\\alpha\\) wavelengths (e.g. Cu-K\\(\\alpha\\) = 1.54056 Angstroms whereas Co-K\\(\\alpha\\) = 1.78897 Angstroms). These wavelengths determine the \\(2\\theta\\) at which the conditions for diffraction are met via Braggs Law: \\[ \\begin{aligned} n\\lambda = 2d\\sin\\theta \\end{aligned} \\] where \\(n\\) is an integer describing the diffraction order, \\(\\lambda\\) is the wavelength (Angstroms) and \\(d\\) is the atomic spacing (Angstroms). In some instances it can be useful to transform the \\(2\\theta\\) axis of a given sample so that the \\(2\\theta\\) peak positions are representative of a measured made using a different X-ray source. This can be achieved using the tth_transform() function: #Create a multiXY object for this transform example transform_eg &lt;- as_multi_xy(list(&quot;Co&quot; = xy_list1$D5000_1, &quot;Cu&quot; = soils$sandstone)) #Plot two patterns recorded using different wavelengths plot(transform_eg, wavelength = &quot;Cu&quot;, normalise = TRUE, interactive = FALSE) Figure 1.17: Data obtained from Co and Cu X-ray tubes prior to 2theta transformation. #transform the 2theta of the &quot;Co&quot; sample to &quot;Cu&quot; transform_eg$Co$tth &lt;- tth_transform(transform_eg$Co$tth, from = 1.78897, to = 1.54056) #Replot data after transformation plot(transform_eg, wavelength = &quot;Cu&quot;, normalise = TRUE, interactive = FALSE) Figure 1.18: Data obtained from Co and Cu X-ray tubes prior to 2theta transformation. #transform the 2theta of the &quot;Co&quot; sample to &quot;Cu&quot; transform_eg$Co$tth &lt;- tth_transform(transform_eg$Co$tth, from = 1.78897, to = 1.54056) #Replot data after transformation plot(transform_eg, wavelength = &quot;Cu&quot;, normalise = TRUE, interactive = FALSE) Figure 1.19: Data obtained from Co and Cu X-ray tubes after 2theta transformation. Note how prior to the \\(2\\theta\\) transformation, the dominant peaks in each pattern (associated with quartz in both cases) do not align. After the \\(2\\theta\\) transformation the peaks are almost aligned, with a small additional \\(2\\theta\\) shift that could be computed using the align_xy() function outlined above. Whilst Cu and Co are the most common X-ray sources for laboratory diffractometers, tth_transform() can accept any numeric wavelength value. References "],["quant.html", "Chapter 2 Quantitative phase analysis 2.1 Full pattern summation with powdR 2.2 Plotting powdRfps and powdRafps objects 2.3 Quantifying multiple samples 2.4 Summarising mineralogy 2.5 The powdR Shiny app", " Chapter 2 Quantitative phase analysis Benjamin Butler and Steve Hillier This chapter describes methods for quantitative analysis implemented within the powdR package using a range of reproducible examples. Detailed accounts of these methods are provided in Butler and Hillier (2021a) and Butler and Hillier (2021b). One of the most powerful properties of XRPD data is that the intensities of crystalline (e.g., quartz, calcite and gypsum), disordered (e.g., clay minerals), and amorphous (e.g., volcanic glass and organic matter) signals within a diffractogram can be related to their concentrations within the mixture. This principal facilitates the quantification of phase concentrations from XRPD data. Of the approaches available for quantitative XRPD, the simple Reference Intensity Ratio (RIR) method has consistently proven accurate. A RIR is a measure of the diffracting power of a phase relative to that of a standard (most often corundum, Al2O3), usually measured in a 50:50 mixture by weight. The RIR of a detectable phase within a mixture is required for its quantification. As mentioned in Chapter 1, a given diffractogram can be modeled as the sum of pure diffractograms for all detectable phases, each scaled by different amounts (scaling factors). By combining these scaling factors with RIRs, phase concentrations can be calculated. Hereafter this approach is referred to as full pattern summation. Full pattern summation is particularly suitable for mixtures containing crystalline mineral components in combination with disordered and/or X-ray amorphous phases. Soil is a prime example of such mixtures, where crystalline minerals such as quartz and feldspars can be present in combination with clay minerals (i.e. disordered phases), and organic matter (i.e. amorphous phases). A key component of the full pattern summation approach is the reference library containing measured or calculated patterns of the pure phases that may be encountered within the samples. The reference patterns within the library would ideally be measured on the same instrument as the sample, however in some cases this isnt possible and the data can be harmonised accordingly. To quantify a given sample, suitable phases from the library are selected that together account for the peaks within the data, and their relative contributions to the observed signal optimised until an appropriate fit is achieved. This fit is usually refined using least squares optimisation of an objective parameter. The scaled intensities of the optimised patterns are then converted to weight % using the RIRs [see Section 2 in (Butler and Hillier 2021a)]. 2.1 Full pattern summation with powdR 2.1.1 The powdRlib object A key component of the full pattern summation functions within powdR is the library of reference patterns. These are stored within a powdRlib object created from two basic components using the powdRlib() constructor function. The first component, specified via the xrd_table argument of powdRlib(), is a data frame of the count intensities of the reference patterns, with their 2\\(\\theta\\) axis as the first column. The column for a given reference pattern must be named using a unique identifier (a phase ID). An example of such a format is provided in the minerals_xrd data: library(powdR) data(minerals_xrd) head(minerals_xrd) ## tth QUA.1 QUA.2 FEL ORT SAN ALB OLI DOL.1 DOL.2 ILL KAO GOE.1 GOE.2 ORG ## 1 4.00973 69 91 546 599 638 308 343 268 362 3078 525 3549 10000 3225 ## 2 4.04865 69 92 524 570 609 294 332 256 345 2960 500 3511 9592 3180 ## 3 4.08757 64 86 505 555 582 286 328 250 343 2888 486 3401 9323 3135 ## 4 4.12649 64 83 512 543 558 277 310 247 327 2753 474 3290 9042 3092 ## 5 4.16541 62 83 478 518 536 275 304 241 318 2718 478 3194 9248 3050 ## 6 4.20433 60 81 459 514 517 261 298 228 314 2720 447 3113 8557 3010 The second component required to build a powdRlib object, specified via the phases_table argument of powdRlib(), is a data frame containing 3 columns. The first column is a string of unique IDs corrensponding to the names of each reference pattern in the data provided to the xrd_table argument outlined above. The second column is the name of the phase group that this reference pattern belongs to (e.g. quartz, plagioclase, Illite etc). The third column is the reference intensity ratio (RIR) of that reference pattern (relative to a known standard, usually corundum). An example of the format required for the phases_table argument of powRlib() is provided in the minerals_phases data. data(minerals_phases) minerals_phases ## phase_id phase_name rir ## 1 QUA.1 Quartz 4.62 ## 2 QUA.2 Quartz 4.34 ## 3 FEL K-feldspar 0.75 ## 4 ORT K-feldspar 1.03 ## 5 SAN K-feldspar 0.93 ## 6 ALB Plagioclase 1.31 ## 7 OLI Plagioclase 1.06 ## 8 DOL.1 Dolomite 2.35 ## 9 DOL.2 Dolomite 2.39 ## 10 ILL Illite 0.22 ## 11 KAO Kaolinite 0.91 ## 12 GOE.1 Goethite 0.93 ## 13 GOE.2 Goethite 0.37 ## 14 ORG Organic-Matter 0.07 Crucially when building the powdRlib object, all phase IDs in the first column of the phases_table must match the column names of the xrd_table (excluding the name of the first column which is the 2\\(\\theta\\) axis), for example. identical(names(minerals_xrd[-1]), minerals_phases$phase_id) ## [1] TRUE Once created, powdRlib objects can easily be visualised using the associated plot() method (see ?plot.powdRlib), which accepts the arguments wavelength, refs and interactive that are used to specify the X-ray wavelength, the reference patterns to plot, and the output format, respectively. In all cases where plot() is used in this chapter, the use of interactive = TRUE in the function call will produce an interactive html graph that can be viewed in RStudio or a web browser. my_lib &lt;- powdRlib(minerals_xrd, minerals_phases) plot(my_lib, wavelength = &quot;Cu&quot;, refs = c(&quot;ALB&quot;, &quot;DOL.1&quot;, &quot;QUA.1&quot;, &quot;GOE.2&quot;), interactive = FALSE) Figure 2.1: Plotting selected reference patterns from a powdRlib object. 2.1.1.1 Pre-loaded powdRlib objects There are two powdRlib objects provided as part of the powdR package. The first is minerals (accessed via data(minerals)), which is a simple and low resolution library designed to facilitate fast computation of basic examples. The second is rockjock (accessed via data(rockjock)), which is a comprehensive library of 169 reference patterns covering most phases that might be encountered in geological and soil samples. The rockjock library in powdR uses data from the original RockJock program (Eberl 2003) thanks to the permission of Dennis Eberl. In rockjock, each reference pattern from the original RockJock program has been scaled to a maximum intensity of 10000 counts, and the RIRs normalised relative to Corundum. All rockjock data were analysed using Cu K\\(\\alpha\\) radiation. To accompany the rockjock reference library, a list of eight synthetic mixtures from the original RockJock program (Eberl 2003) are also included in powdR in the rockjock_mixtures data (accessed via data(rockjock_mixtures)), and the known compositions of these mixtures provided in the rockjock_weights data (accessed via data(rockjock_weights)). 2.1.1.2 Subsetting a powdRlib object Occasionally it may be useful to subset a reference library to a smaller selection. This can be achieved using subset(), which for powdRlib objects accepts three arguments; x, refs and mode (see ?subset.powdRlib). The x argument specifies the powdRlib object to be subset, refs specifies the IDs and/or names of phases to select, and mode specifies whether these phases are kept (mode = \"keep\") or removed (mode = \"remove\"). data(rockjock) #Have a look at the phase ID&#39;s in rockjock rockjock$phases$phase_id[1:10] ## [1] &quot;CORUNDUM&quot; &quot;BACK_POS&quot; ## [3] &quot;BACK_NEG&quot; &quot;QUARTZ&quot; ## [5] &quot;ORDERED_MICROCLINE&quot; &quot;INTERMEDIATE_MICROCLINE&quot; ## [7] &quot;SANIDINE&quot; &quot;ORTHOCLASE&quot; ## [9] &quot;ANORTHOCLASE&quot; &quot;ALBITE_CLEAVELANDITE&quot; #Remove reference patterns from rockjock rockjock_1 &lt;- subset(rockjock, refs = c(&quot;ALUNITE&quot;, #phase ID &quot;AMPHIBOLE&quot;, #phase ID &quot;ANALCIME&quot;, #phase ID &quot;Plagioclase&quot;), #phase name mode = &quot;remove&quot;) #Check number of reference patterns remaining in library nrow(rockjock_1$phases) ## [1] 157 #Keep certain reference patterns of rockjock rockjock_2 &lt;- subset(rockjock, refs = c(&quot;ALUNITE&quot;, #phase ID &quot;AMPHIBOLE&quot;, #phase ID &quot;ANALCIME&quot;, #phase ID &quot;Plagioclase&quot;), #phase name mode = &quot;keep&quot;) #Check number of reference patterns remaining nrow(rockjock_2$phases) ## [1] 11 2.1.1.3 Interpolating and merging powdRlib objects Two powdRlib objects from different instruments can be interpolated and then merged using the interpolate and merge methods (see ?interpolate.powdRlib and merge.powdRlib), respectively. For example, the minerals library can be merged with the rockjock library following interpolation using: #Load the minerals library data(minerals) #Check the number of reference patterns nrow(minerals$phases) ## [1] 14 #Load the rockjock library data(rockjock) #Check the number of reference patterns nrow(rockjock$phases) ## [1] 168 #interpolate minerals library onto same 2theta as rockjock minerals_i &lt;- interpolate(minerals, new_tth = rockjock$tth) #merge the libraries merged_lib &lt;- merge(rockjock, minerals_i) #Check the number of reference patterns in the merged library nrow(merged_lib$phases) ## [1] 182 In simpler cases where two libraries are already on the same \\(2\\theta\\) axis and were measured using the same instrumental parameters, only the use of merge() would be required. 2.1.2 Full pattern summation with fps() Once you have a powdRlib reference library and diffractogram(s) loaded into R, you have everything needed for quantitative analysis via full pattern summation. Full pattern summation in powdR is provided via the fps() function, whilst an automated version is provided in afps(). Details of the equations and routines implemented in fps() and afps() are provided in Butler and Hillier (2021a) and Butler and Hillier (2021b). fps() is specifically applied to powdRlib objects, and accepts a wide range of arguments that are detailed in the package documentation (see ?fps.powdRlib). Here the rockjock and rockjock_mixtures data will be used to demonstrate the main features of fps() and the various ways in which it can be used. 2.1.2.1 Full pattern summation with an internal standard Often samples are prepared for XRPD analysis with an internal standard of known concentration. If this is the case, then the std and std_conc arguments of fps() can be used to define the internal standard and its concentration (in weight %), respectively, which is then used in combination with the reference intensity ratios to compute phase concentrations. For example, all samples in the rockjock_mixtures data were prepared with 20 % corundum as the internal standard, thus this can be specified using std = \"CORUNDUM\" and std_conc = 20 in the call to fps(). In addition, setting the omit_std argument to TRUE makes sure that the internal standard concentration will be omitted from the output and the phase concentrations recomputed accordingly. In such cases the phase specified as the internal standard can also be used in combination with the value specified in the align argument to ensure that the measured diffractogram is appropriately aligned on the \\(2\\theta\\) axis using the alignment approach outlined above. These principles are used in the example below, which passes the following seven arguments to fps(): lib is used to define the powdRlib object containing the reference patterns and their RIRs. smpl is used to defined the data frame or XY object containing the sample diffractogram. refs is used to define a string of phase IDs (lib$phases$phase_id) and/or phase names (lib$phases$phase_names) of the reference patterns to be used in the fitting process. std is used to define the phase ID of the reference pattern to be used as the internal standard. std_conc is used to define the concentration of the internal standard in weight %. omit_std is used to define whether the internal standard is omitted from the output and phase concentrations recomputed accordingly. align is used to define the maximum positive or negative shift in \\(2\\theta\\) that is permitted during alignment of the sample to the reference pattern that is specified in the std argument. data(rockjock_mixtures) fit1 &lt;- fps(lib = rockjock, smpl = rockjock_mixtures$Mix1, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;LABRADORITE&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;), std = &quot;CORUNDUM&quot;, std_conc = 20, omit_std = TRUE, align = 0.3) ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Computing phase concentrations ## -Using internal standard concentration of 20 % to compute phase concentrations ## -Omitting internal standard from phase concentrations ## ***Full pattern summation complete*** Once computed, the fps() function produces a powdRfps object, which is a bundle of data in list format that contains the outputs (see ?fps.powdRlib). summary(fit1) ## Length Class Mode ## tth 2989 -none- numeric ## fitted 2989 -none- numeric ## measured 2989 -none- numeric ## residuals 2989 -none- numeric ## phases 4 data.frame list ## phases_grouped 2 data.frame list ## obj 3 -none- numeric ## weighted_pure_patterns 6 data.frame list ## coefficients 6 -none- numeric ## inputs 16 -none- list The phase concentrations can be accessed in the phases data frame of the powdRfps object: fit1$phases ## phase_id phase_name rir phase_percent ## 2 ORDERED_MICROCLINE K-feldspar 0.9654312 4.51300 ## 3 LABRADORITE Plagioclase 0.8113040 24.15963 ## 4 KAOLINITE_DRY_BRANCH Kaolinite 0.5812875 14.60875 ## 5 ILLITE_1M_RM30 Illite 0.2768664 8.02925 ## 6 MONTMORILLONITE_WYO Smectite (Di) 0.3202779 51.18163 Further, notice that if the concentration of the internal standard is specified then the phase concentrations do not necessarily sum to 100 %: sum(fit1$phases$phase_percent) ## [1] 102.4923 Unlike other software where only certain phases can be used as an internal standard, any phase can be defined in powdR. For example, the rockjock_mixtures$Mix5 sample contains 20 % quartz (see data(rockjock_weights)), thus adding \"QUARTZ\" as the std argument results in this reference pattern becoming the internal standard instead. fit2 &lt;- fps(lib = rockjock, smpl = rockjock_mixtures$Mix5, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;LABRADORITE&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;CORUNDUM&quot;, &quot;QUARTZ&quot;), std = &quot;QUARTZ&quot;, std_conc = 20, omit_std = TRUE, align = 0.3) ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Computing phase concentrations ## -Using internal standard concentration of 20 % to compute phase concentrations ## -Omitting internal standard from phase concentrations ## ***Full pattern summation complete*** fit2$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Corundum 1.0000000 24.893125 ## 3 ORDERED_MICROCLINE K-feldspar 0.9654312 41.334625 ## 4 LABRADORITE Plagioclase 0.8113040 9.809250 ## 5 KAOLINITE_DRY_BRANCH Kaolinite 0.5812875 5.399625 ## 6 MONTMORILLONITE_WYO Smectite (Di) 0.3202779 14.022375 sum(fit2$phases$phase_percent) ## [1] 95.459 Its also possible to close the mineral composition so that the weight percentages sum to 100. This can be achieved in two ways: By defining closed = TRUE in the fps() function call. By applying the close_quant() function to the powdRfps output. For example, the phase composition in fit2 created above can be closed using: fit2c &lt;- close_quant(fit2) sum(fit2c$phases$phase_percent) ## [1] 100 2.1.2.2 Full pattern summation without an internal standard In cases where an internal standard is not added to a sample, phase quantification can be achieved by assuming that all detectable phases can be identified and that they sum to 100 weight %. By setting the std_conc argument of fps() to NA, or leaving it out of the function call, it will be assumed that the sample has been prepared without an internal standard and the phase concentrations computed accordingly. fit3 &lt;- fps(lib = rockjock, smpl = rockjock_mixtures$Mix1, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;LABRADORITE&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;), std_conc = NA, std = &quot;CORUNDUM&quot;, align = 0.3) ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** In this case the phase specified in the std argument is only used for \\(2\\theta\\) alignment, and is always included in the computed phase concentrations. fit3$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Corundum 1.0000000 19.6090 ## 2 ORDERED_MICROCLINE K-feldspar 0.9654312 3.5399 ## 3 LABRADORITE Plagioclase 0.8113040 18.9498 ## 4 KAOLINITE_DRY_BRANCH Kaolinite 0.5812875 11.4586 ## 5 ILLITE_1M_RM30 Illite 0.2768664 6.2978 ## 6 MONTMORILLONITE_WYO Smectite (Di) 0.3202779 40.1449 Furthermore, the phase concentrations computed using this approach will always sum to 100 %. sum(fit3$phases$phase_percent) ## [1] 100 2.1.2.3 Full pattern summation with data harmonisation It is usually recommended that the reference library used for full pattern summation is measured on the same instrument as the sample using an identical 2\\(\\theta\\) range and resolution. In some cases this is not feasible, and the reference library patterns may be from a different instrument to the sample. To allow for seamless use of samples and libraries from different instruments (measured using the same X-ray wavelength), fps() contains a logical harmonise argument (default = TRUE). When the sample and library contain non-identical 2\\(\\theta\\) axes, harmonise = TRUE will convert the data onto the same axis by determining the overlapping 2\\(\\theta\\) range and interpolating to the coarsest resolution available. #Create a sample with a shorter 2theta axis than the library Mix1_short &lt;- subset(rockjock_mixtures$Mix1, tth &gt; 10 &amp; tth &lt; 55) #Reduce the resolution by selecting only odd rows of the data Mix1_short &lt;- Mix1_short[seq(1, nrow(Mix1_short), 2),] fit4 &lt;- fps(lib = rockjock, smpl = Mix1_short, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;LABRADORITE&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;), std = &quot;CORUNDUM&quot;, align = 0.3) ## ## -Harmonising library to the same 2theta resolution as the sample ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** fit4$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Corundum 1.0000000 19.5079 ## 2 ORDERED_MICROCLINE K-feldspar 0.9654312 3.8663 ## 3 LABRADORITE Plagioclase 0.8113040 19.8705 ## 4 KAOLINITE_DRY_BRANCH Kaolinite 0.5812875 12.8507 ## 5 ILLITE_1M_RM30 Illite 0.2768664 8.4559 ## 6 MONTMORILLONITE_WYO Smectite (Di) 0.3202779 35.4486 2.1.3 Automated full pattern summation The selection of suitable reference patterns for full pattern summation can often be challenging and time consuming. An attempt to automate this process is provided in the afps() function, which can select appropriate reference patterns from a reference library and subsequently exclude reference patterns based on limit of detection estimates. Such an approach is considered particularly advantageous when quantifying high-throughput XRPD datasets that display considerable mineralogical variation such as the Reynolds Cup. Detailed accounts of the afps() function are provided in Butler and Hillier (2021a) and Butler and Hillier (2021b). All of the principles and arguments outlined above for the fps() function apply to the use of afps(). When using afps(), there are a few additional arguments that need to be defined: force is used to specify phase IDs (lib$phases$phase_id) or phase names (lib$phases$phase_name) that must be retained in the output, even if their concentrations are estimated to be below the limit of detection or negative. lod is used to define the limit of detection (LOD; in weight %) of the phase specified as the internal standard in the std argument. This limit of detection for the define phase is then used in combination with the RIRs to estimate the LODs of all other phases. amorphous is used to specify which, if any, phases should be treated as amorphous. This is used because the assumptions used to estimate the LODs of crystalliane and disordered phases are not appropriate for amorphous phases. amorphous_lod is used to define the LOD (in weight %) of the phases specified in the amorphous argument. Here the rockjock library, containing 169 reference patterns, will be used to quantify one of the samples in the rockjock_mixtures data. Note that when using afps(), omission of the refs argument in the function call will automatically result in all phases from the reference library being used in the fitting process. #Produce the fit a_fit1 &lt;- afps(lib = rockjock, smpl = rockjock_mixtures$Mix1, std = &quot;CORUNDUM&quot;, align = 0.3, lod = 1) ## ## -Using all reference patterns in the library ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Applying non-negative least squares ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Calculating detection limits ## -Removing phases below detection limit ## -Reoptimising after removing crystalline phases below the limit of detection ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Automated full pattern summation complete*** Once computed, the afps function produces a powdRafps object, which is a bundle of data in list format that contains the outputs (see ?afps.powdRlib). When large libraries such a rockjock are used to quantify a given sample, the resulting output is likely contain several different reference patterns for a given mineral, for example: table(a_fit1$phases$phase_name) ## ## Background Corundum Illite K-feldspar Kaolinite ## 1 1 2 1 1 ## Plagioclase Smectite (Di) ## 3 2 Illustrates that the resulting output contains 2 reference patterns for both illite and Smectite, 3 patterns for plagioclase, and 1 pattern for each of the other phases selected by afps(). This information is grouped together and summed in the phases_grouped data frame within the powdRafps object: a_fit1$phases_grouped ## phase_name phase_percent ## 1 Corundum 19.2449 ## 2 Background 0.0001 ## 3 K-feldspar 2.6398 ## 4 Plagioclase 19.2431 ## 5 Kaolinite 10.8828 ## 6 Smectite (Di) 40.0788 ## 7 Illite 7.9105 Note that the background phase in the output is simply a horizontal line that can account for shifts in background intensity, which can be useful to use in some cases. In the rockjock data, the background patterns have been given an exceptionally high RIR so that their quantified concentrations are near zero. 2.1.4 Additional fps() and afps() functionality 2.1.4.1 Shifting of reference patterns Both fps() and afps() accept a shift argument, which when set to a value greater than zero results in optimisation of a small \\(2\\theta\\) shift for each reference pattern in order to improve the quality of the fit. The value supplied to the shift argument defines the maximum (either positive or negative) shift that can be applied to each reference pattern before the shift is reset to zero. This shifting process is designed to correct for small linear differences in the peak positions of the standards relative to the sample, which may result from a combination of instrumental aberrations, mineralogical variation and/or uncorrected errors in the library patterns. Whilst it provides more accurate results, the process can substantially increase computation time. 2.1.4.2 Regrouping phases in powdRfps and powdRafps objects Occasionally it can be useful to apply a different grouping structure to the phases quantified within a powdRfps or powdRafps object. This can be achieved using the regroup function (see ?regroup.powdRfps and ?regroup.powdRafps): #View the phases of the a_fit1 output a_fit1$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Corundum 1.000000e+00 19.2449 ## 2 BACK_NEG Background 1.000000e+04 0.0001 ## 3 ORDERED_MICROCLINE K-feldspar 9.654312e-01 2.6398 ## 4 ANDESINE Plagioclase 8.206422e-01 3.2496 ## 5 LABRADORITE Plagioclase 8.113040e-01 15.8851 ## 6 BYTOWNITE Plagioclase 7.250736e-01 0.1084 ## 7 ORD_KAOLINITE Kaolinite 6.684230e-01 10.8828 ## 8 CA_MONTMORILLONITE Smectite (Di) 2.920099e-01 16.1587 ## 9 ILLITE_1M_RM30 Illite 2.768664e-01 4.9353 ## 10 MONTMORILLONITE_WYO Smectite (Di) 3.202779e-01 23.9201 ## 11 ILLITE_R0_5_PERCENT_I Illite 2.620735e-01 2.9752 #Extract the phase IDs for the regrouping structure rg_id &lt;- a_fit1$phases$phase_id #Create a new grouping structure for those IDs rg_name &lt;- c(&quot;Non-clay&quot;, #CORUNDUM &quot;Background&quot;, #BACK_NEG &quot;Non-clay&quot;, #ORDERED_MICROCLINE &quot;Non-clay&quot;, #ANDESINE &quot;Non-clay&quot;, #LABRADORITE &quot;Non-clay&quot;, #BYTOWNITE &quot;Clay&quot;, #ORD_KAOLINITE &quot;Clay&quot;, #CA_MONTMORILLONITE &quot;Clay&quot;, #ILLITE_1M_RM30 &quot;Clay&quot;, #MONTMORILLONITE_WYO &quot;Clay&quot; #ILLITE_R0_5_PERCENT_I ) #Create a data frame from that structure rg_str &lt;- data.frame(&quot;phase_id&quot; = rg_id, &quot;phase_name&quot; = rg_name) #Regroup the data in a_fit1 a_fit1_rg &lt;- regroup(a_fit1, rg_str) #Check the regrouped data a_fit1_rg$phases_grouped ## phase_name phase_percent ## 1 Background 0.0001 ## 2 Clay 58.8721 ## 3 Non-clay 41.1278 2.2 Plotting powdRfps and powdRafps objects Plotting results powdRfps and powdRafps objects, derived from fps() and afps(), respectively, is achieved using plot() (see ?plot.powdRfps and ?plot.powdRafps). plot(a_fit1, wavelength = &quot;Cu&quot;, interactive = FALSE) Figure 2.2: Example output from plotting a powdRfps or powdRafps object. When plotting powdRfps or powdRafps objects the wavelength must be defined because it is required to compute d-spacings that are shown when interactive = TRUE. As with other plotting methods outlined in Section 1.3, interactive ggplotly() outputs can be created using interactive = TRUE. In addition to above, plotting for powdRfps and powdRafps objects can be further adjusted by the group, mode and xlim arguments. When the group argument is set to TRUE, the patterns within the fit are grouped and summed according to phase names, which can help simplify the plot: plot(a_fit1, wavelength = &quot;Cu&quot;, group = TRUE, interactive = FALSE) Figure 2.3: Plotting a powdRfps or powdRafps object with the reference patterns grouped. The mode argument can be one of \"fit\" (the default), \"residuals\" or \"both\", for example: plot(a_fit1, wavelength = &quot;Cu&quot;, mode = &quot;residuals&quot;, interactive = FALSE) Figure 2.4: Plotting the residuals of a powdRfps or powdRafps object. or alternatively both the fit and residuals can be plotted using mode = \"both\" and the \\(2\\theta\\) axis restricted using the xlim argument: plot(a_fit1, wavelength = &quot;Cu&quot;, mode = &quot;both&quot;, xlim = c(20,30), interactive = FALSE) Figure 2.5: Plotting both the fit and residuals of a powdRfps or powdRafps object. 2.3 Quantifying multiple samples 2.3.1 lapply() The simplest way to quantify multiple samples via either fps() and afps() is by wrapping either of the functions in lapply() and supplying a list of diffractograms. The following example wraps the fps() function in lapply and applies the function to the first three items within the rockjock_mixtures data. multi_fit &lt;- lapply(rockjock_mixtures[1:3], fps, lib = rockjock, std = &quot;CORUNDUM&quot;, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;LABRADORITE&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;, &quot;QUARTZ&quot;), align = 0.3) ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** When using lapply in this way, the names of the items within the list or multiXY object supplied to the function are inherited by the output: names(rockjock_mixtures[1:3]) ## [1] &quot;Mix1&quot; &quot;Mix2&quot; &quot;Mix3&quot; names(multi_fit) ## [1] &quot;Mix1&quot; &quot;Mix2&quot; &quot;Mix3&quot; 2.3.2 Parallel processing Whilst lapply is a simple way to quantify multiple samples, the computation remains restricted to a single core. Computation time can be reduced many-fold by allowing different cores of your machine to process one sample at a time, which can be achieved using the doParallel and foreach packages: #Install the foreach and doParallel package install.packages(c(&quot;foreach&quot;, &quot;doParallel&quot;)) #load the packages library(foreach) library(doParallel) #Detect number of cores on machine UseCores &lt;- detectCores() #Register the cluster using n - 1 cores cl &lt;- makeCluster(UseCores-1) registerDoParallel(cl) #Use foreach loop and %dopar% to compute in parallel multi_fit &lt;- foreach(i = 1:3) %dopar% (powdR::fps(lib = rockjock, smpl = rockjock_mixtures[[i]], std = &quot;CORUNDUM&quot;, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;LABRADORITE&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;, &quot;QUARTZ&quot;), align = 0.3)) #name the items in the aquant_parallel list names(multi_fit) &lt;- names(rockjock_mixtures)[1:3] #stop the cluster stopCluster(cl) Note how the call to fps uses the notation powdR::fps(), which specifies the accessing of the fps() function from the powdR package. 2.4 Summarising mineralogy When multiple samples are quantified it is often useful to report the phase concentrations of all of the samples in a single table. For a given list of powdRfps and/or powdRafps objects, the summarise_mineralogy() function yields such summary tables, for example: summarise_mineralogy(multi_fit, type = &quot;grouped&quot;, order = TRUE) ## sample_id Kaolinite Corundum Plagioclase Smectite (Di) Illite K-feldspar ## 1 Mix1 11.4255 19.6390 18.9222 40.2223 6.0943 3.4771 ## 2 Mix2 19.9893 20.1257 34.2955 3.1401 9.8914 7.9668 ## 3 Mix3 38.0548 20.1476 NA 3.5897 19.4220 11.0541 ## Quartz ## 1 0.2197 ## 2 4.5911 ## 3 7.7318 where type = \"grouped\" denotes that phases with the same phase_name will be summed together, and order = TRUE specifies that the columns will be ordered from most common to least common (assessed by the sum of each column). Using type = \"all\" instead would result in tabulation of all phase IDs. In addition to the quantitative mineral data, three objective parameters that summarise the quality of the fit can be appended to the table via the logical rwp, r and delta arguments. summarise_mineralogy(multi_fit, type = &quot;grouped&quot;, order = TRUE, rwp = TRUE, r = TRUE, delta = TRUE) ## sample_id Kaolinite Corundum Plagioclase Smectite (Di) Illite K-feldspar ## 1 Mix1 11.4255 19.6390 18.9222 40.2223 6.0943 3.4771 ## 2 Mix2 19.9893 20.1257 34.2955 3.1401 9.8914 7.9668 ## 3 Mix3 38.0548 20.1476 NA 3.5897 19.4220 11.0541 ## Quartz Rwp R Delta ## 1 0.2197 0.1193771 0.1165048 39834.67 ## 2 4.5911 0.1237287 0.1115322 36910.18 ## 3 7.7318 0.1141585 0.1077551 37571.72 For each of these parameters, lower values represent a smaller difference between the measured and fitted patterns, and hence are indicative of a better fit. For more information see Section 2.1 in Butler and Hillier (2021b). 2.5 The powdR Shiny app All above examples showcase the use of R code to carry out full pattern summation. It is also possible to run much of this functionality of powdR via a Shiny web application. This Shiny app can be loaded in your default web browser by running run_powdR(). The resulting application has six tabs: Reference Library Builder: Allows you to create and export a powdRlib reference library from two .csv files: one for the XRPD measurements, and the other for the ID, name and reference intensity ratio of each pattern. Reference Library Viewer: Facilitates quick inspection of the phases within a powdRlib reference library. Reference Library Editor: Allows the user to easily subset a powdRlib reference library . Full Pattern Summation: A user friendly interface for iterative full pattern summation of single samples using fps() or afps(). Results Viewer/Editor: Allows for results from previously saved powdRfps and powdRafps objects to be viewed and edited via addition or removal of reference patterns. Help Provides a series of video tutorials (via YouTube) detailing the use of the powdR Shiny application. References "],["machine-learning.html", "Chapter 3 Machine learning with soil XRPD data 3.1 Loading data 3.2 Data exploration 3.3 Data pre-treatment 3.4 Using Cubist 3.5 Inspection of Cubist models", " Chapter 3 Machine learning with soil XRPD data Benjamin Butler This chapter will demonstrate the use of the Cubist machine learning algorithm to predict and interpret soil properties from XRPD data. Cubist is an extension of Quinlans M5 model tree (Quinlan 1992), and is featured in the CRAN repository under the same name for use in the R statistical software environment (Kuhn and Quinlan 2021). Cubist defines a series of conditions based on predictor variables (i.e. the XRPD measurement intervals) that partition the data. At each partition there is a multivariate linear model used to predict the output (i.e. the soil property). The examples presented herein for the use of Cubist will use data from Butler et al. (2020) that is hosted on Mendeley Data here. More specifically, to run the examples in this chapter on your own machine, you will need to download the soil property data in .csv format and the XRPD data in a zipped folder of xy files. Please simply save these files to your own directory, and unzip the zipped folder containing the .xy files. Download soil property csv Download zipped XRPD data 3.1 Loading data Once you have downloaded the data required for this chapter, it can be loaded into R by modifying the paths in the following code: library(powdR) #Load the soil property data props &lt;- read.csv(file = &quot;path/to/your/file/clusters_and_properties.csv&quot;) #Load the XRPD data #Get the full file paths xrpd_paths &lt;- dir(&quot;path/to/xrd&quot;, full.names = TRUE) #Load the data xrpd &lt;- read_xy(files = xrpd_paths) 3.2 Data exploration The data represent 935 sub-soil samples from sub-Saharan Africa, sampled as part of the AfSIS Sentinel Site programme using the Land Degradation Surveillance Framework. A range of soil attributes and properties are provided in the props data, whilst each item within the xrpd data is an XY diffractogram of the soil. The names of xrpd data correspond to unique identifiers in the props$SSN column: #Check that the names of the xrpd data match the SSN column in props identical(names(xrpd), props$SSN) ## [1] TRUE 3.2.1 Spatial data The first 4 columns of the props data include the unique SSN identifier of each sample, the name of the Sentinel Site, and the sample location (Longitude and Latitude). Initial exploration of the spatial distribution of the dataset can be achieved using the leaflet package (Cheng, Karambelkar, and Xie 2021), which can be installed using install.packages(leaflet). A detailed guide of how to use leaflet in R is beyond the scope of this documentation, but the code used below can be adapted to produce basic plots of geo-referenced point data. Leaflet maps are built up in layers similar to the principle of ggplot2 figures, with each layer being separated by a %&gt;%, which can be written in R using the Ctrl+Shift+M shortcut. library(leaflet) leaflet(props) %&gt;% #create a leaflet object from props addTiles() %&gt;% #add the default tiles for the map surface addCircleMarkers(~Longitude, ~Latitude) Figure 3.1: Interactive map of the Sentinel Site data showing all 60 sites across sub-Saharan Africa. The first map above shows the 60 Sentinel Sites within the dataset that together reflect the various agro-ecological regions of sub-Saharan Africa. By zooming in ON one of the sentinel sites, it can be observed that it is comprised of a random grid of up to 16 samples within a 10 x 10 km area: library(leaflet) leaflet(props[props$Sentinel_site == &quot;Bana&quot;,]) %&gt;% addTiles() %&gt;% addCircleMarkers(~Longitude, ~Latitude) Figure 3.2: Interactive map of the Sentinel Site data showing all one of the sites and the sixteen sampling locations within it. 3.2.2 Geochemical data The props data contains a wide range of geochemical variables including pH, total organic carbon (TOC), total element concentrations (columns 9 to 15) and Mehlich-3 extractable element concentrations (columns 16 to 23). The example provided in this chapter will focus on total concentrations of K, determined using X-ray Fluorescence (Butler et al. (2020)), but the code can be easily adjusted and used for any other soil property within the dataset. library(ggplot2) ggplot(data = props, aes(log(K))) + geom_histogram() Figure 3.3: Histogram of total K concentrations (log transformed) 3.2.3 XRPD data Given there are 935 diffractograms within the xrpd data, it is not possible to visually inspect all data at once. To start with, it is probably worth visualising the diffractograms from one Sentinel site at a time. plot(as_multi_xy(xrpd[props$SSN[props$Sentinel_site == &quot;Didy&quot;]]), wavelength = &quot;Cu&quot;, normalise = TRUE) Figure 3.4: Diffractograms associated with the Didy site. Visualising the data in this way shows how the strongest peak in each diffractogram at the Didy Sentinel Site occurs at approximately 26 \\(^\\circ2\\theta\\). Further inspection of this peak shows how there are minor adjustments in alignment that will need to be applied to the data: plot(as_multi_xy(xrpd[props$Sentinel_site == &quot;Didy&quot;]), wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26,27)) Figure 3.5: The major quartz peak of the diffractograms associated with the Didy site, highlighting small 2theta misalignments. This strong peak is associated with quartz, which is omnipresent in soil datasets like this and is a strong diffractor of X-rays. Together this results in quartz peaks being the dominant signal in most soil diffractograms, which is a feature that can be particularly useful for peak alignment when pre-treating the data. 3.3 Data pre-treatment Prior to applying Cubist to the XRPD data, it is important to apply corrections for sample-independent variation such as small \\(2\\theta\\) misalignments and/or fluctuations in count intensities. Alignment The small \\(2\\theta\\) misalignments identified above can be corrected for using the align_xy() function in powdR. Quartz is omnipresent within the dataset and therefore the samples can be aligned to a pure quartz pattern. A pure quartz pattern can be created from the rockjock library, and then used for sample alignment within a restricted \\(2\\theta\\) range. #Extract a quartz pattern from rockjock quartz &lt;- as_xy(data.frame(rockjock$tth, rockjock$xrd$QUARTZ)) plot(quartz, wavelength = &quot;Cu&quot;) Figure 3.6: A pure quartz pattern extracted from the rockjock reference library. #Align the xrpd data to this quartz pattern #using a restricted 2theta range of 10 to 60 xrpd_pt &lt;- align_xy(xrpd, std = quartz, xmin = 10, xmax = 60, xshift = 0.2) plot(as_multi_xy(xrpd_pt[props$Sentinel_site == &quot;Didy&quot;]), wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26,27)) Figure 3.7: Diffractograms from the Didy site aligned to the quartz pattern extracted from the rockjock reference library. Alignment of the data in this way is important because even seemingly small misalignments between peaks can hinder the comparison of XRPD data by multivariate methods, and hence reduce the effectiveness of the analysis (Butler et al. (2019)). Subsetting In Figure 3.4 it can be observed that below ~4 \\(^\\circ2\\theta\\) there is a tall tail in count intensities. This tail can be removed by subsetting the data using the code described above. subset_xrpd &lt;- function (x, xmin, xmax) { x &lt;- x[x[[1]] &gt;= xmin &amp; x[[1]] &lt;= xmax, ] return(x) } xrpd_pt &lt;- lapply(xrpd_pt, subset_xrpd, xmin = 5, xmax = 75) plot(as_multi_xy(xrpd_pt[props$Sentinel_site == &quot;Didy&quot;]), wavelength = &quot;Cu&quot;) Figure 3.8: Aligned diffractograms subset to remove data below 5 degrees 2theta. Mean centering In addition to alignment and subsetting, it can be useful to adjust the data for fluctuating count intensities that can be associated with factors such as the natural deterioration of the X-ray source over time. Such adjustment can be achieved by mean centering, which subtracts the mean from the count intensities of each sample: #Create a mean centering function mean_center &lt;- function(x) { x[[2]] &lt;- x[[2]] - mean(x[[2]]) return(x) } #apply the function to all patterns xrpd_pt &lt;- lapply(xrpd_pt, mean_center) #Inspect the data from Didy plot(as_multi_xy(xrpd_pt[props$Sentinel_site == &quot;Didy&quot;]), wavelength = &quot;Cu&quot;) Figure 3.9: Aligned, subset and mean centred diffractograms. Now we are left with the dataset xrpd which consists of 935 diffractograms that have each been aligned, subset and mean centred. At this point we are ready to apply the Cubist algorithm to the data. 3.3.1 Creation of training and test datasets Cubist is a supervised machine learning algorithm and therefore requires training using a dataset that accounts for much of the variation that may be observed in the dataset that Cubist predicts a given soil property from. Here, 75 % of the data will be used as a training set for Cubist to develop appropriate decisions and regression models from (hereafter the training dataset. The remaining 25 % of the data will be used to test the accuracy of the derived models on new data (i.e. data that was not used to train the model; hereafter the test dataset). There are a range of different approaches for defining the training and test datasets. Here a purely random approach will be employed using the sample() function: #Set the seed for random number generation #so that results are reproducible. set.seed(10) #Randomly select 75% of the samples selection &lt;- sample(1:nrow(props), size = round(nrow(props)*0.75), replace = FALSE) 3.4 Using Cubist Here Cubist will be applied to the XRPD data in order to predict and interpret total K concentrations. Underpinning this approach is the principle that a soil diffractogram represents a reproducible signature of that soils mineral composition, and the mineral composition is a key controller of total K concentrations. The code can be readily adapted to any of the other properties within the data, or to your own soil XRPD data and associated properties. To run Cubist the XRPD data need to be supplied in dataframe format, with each row of the dataframe representing a sample. The XRPD data can easily be converted to a dataframe using the multi_xy_to_df function outlined above: #double check that the order of xrpd and props #data match identical(names(xrpd_pt), props$SSN) ## [1] TRUE #create a data frame xrpd_df &lt;- multi_xy_to_df(as_multi_xy(xrpd_pt), tth = TRUE) #transpose the data so that each sample is a row cubist_xrpd &lt;- data.frame(t(xrpd_df[-1])) There are a couple of parameters that can be adjusted when training Cubist models: committees and neighbours (see Butler, ORourke, and Hillier (2018)). Various routines exist for tuning these parameters in order to produce the most accurate models. For further reading on this tuning process, see the caret (Kuhn 2021) and Cubist (Kuhn and Quinlan 2021) package documentation . For simplicity, the adjustable Cubist parameters used in this example will be set to committees = 10 when training the models, and neighbours = 9 when using the derived models to predict total K concentrations from new data. The Cubist models can be trained using the training dataset using: library(Cubist) #Create a Cubist model for K cubist_K &lt;- cubist(x = cubist_xrpd[selection,], y = props$K[selection], committees = 10) following which, the derived models can be used to predict the total K concentrations from XRPD data in the test dataset: #Predict K predict_K &lt;- predict(cubist_K, cubist_xrpd[-selection,], neighbours = 9) #Plot measured K vs predicted K plot(x = log(props$K[-selection]), log(predict_K), xlab = &quot;log(Measured K), ppm&quot;, ylab = &quot;log(Predicted K), ppm&quot;) abline(0,1) #Add a 1:1 line #R2 of measured K vs predicted K cor(log(props$K[-selection]), log(predict_K))^2 ## [1] 0.881556 The Cubist model for K prediction therefore results in a relatively accurate prediction of K, with an \\(R^2\\) of ~0.9. This indicates that Cubist is able to extract appropriate variables from the XRPD data and use them to predict chemical soil properties. 3.5 Inspection of Cubist models The variables that Cubist selects can be plotted in order to decipher the mineral contributions to a given soil property: #Extract the usage data from the Cubist model K_usage &lt;- cubist_K$usage #Make sure the variable names are numeric so that they can be ordered K_usage$Variable &lt;- as.numeric(substr(K_usage$Variable, 2, nchar(K_usage$Variable))) #Order the K_usage data by Variable now it is numeric K_usage &lt;- K_usage[order(K_usage$Variable), ] #Add the 2theta axis K_usage$tth &lt;- xrpd_df$tth #Add a mean diffracotgram to the data K_usage$counts &lt;- rowMeans(xrpd_df[-1]) #Create a function that normalises a vector data to a minimum of 0 #and maximum of 1. range01 &lt;- function(x){(x-min(x))/(max(x)-min(x))} #Create the plot ggplot(data = K_usage) + geom_linerange(aes(x = tth, ymax = Model/100, ymin = 0), colour = &quot;grey81&quot;, size = 1) + geom_linerange(aes(x = tth, ymax = Conditions/100, ymin = 0), colour = &quot;grey19&quot;, size = 1) + geom_line(aes(x = tth, y = range01(counts)), colour = &quot;red&quot;, size = 0.5) + ylab(&quot;Scaled counts and fraction of variable use\\n&quot;) + xlab(&quot;2theta&quot;) + theme_bw() Figure 3.10: Features selected by Cubist for the prediction of K. Grey sticks denote the fraction of variable use in the regression models and black sticks denote the fraction of variable use in decision. Red line is the mean diffractogram for the dataset. Figure 3.10 shows how the most important variables for prediction of K concentrations are found between 25 and 30 \\(^\\circ2\\theta\\). To further aid with interpretation of such regions, these plots can be combined with data from full pattern summation so that the variables selected by Cubist can be attributed to specific minerals. For example: f1 &lt;- fps(lib = rockjock, smpl = xrpd$icr014764, std = &quot;QUARTZ&quot;, refs = c(&quot;K-feldspar&quot;, &quot;Quartz&quot;, &quot;Mica (Tri)&quot;, &quot;Organic matter&quot;, &quot;Halloysite&quot;, &quot;Kaolinite&quot;, &quot;Rutile&quot;, &quot;Background&quot;), align = 0.2) ## ## -Harmonising library to the same 2theta resolution as the sample ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Removing negative coefficients and reoptimising... ## -Removing negative coefficients and reoptimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** yields a reasonable fit of the data, as can be inspected using plot(f1, wavelength = \"Cu\", interactive = TRUE). To help identify what minerals the variables between 25 and 30 \\(^\\circ2\\theta\\) are associated with, the results in f1 can be combined with the results in K_usage: #Create a plot of the full pattern summation results p1 &lt;- plot(f1, wavelength = &quot;Cu&quot;, group = TRUE) #Define the layers for the sticks that will have to be placed #BENEATH the data in p1 p2 &lt;- geom_linerange(data = K_usage, aes(x = tth, ymax = (Model/100)*max(f1$measured), ymin = 0), colour = &quot;grey81&quot;, size = 1) p3 &lt;- geom_linerange(data = K_usage, aes(x = tth, ymax = (Conditions/100)*max(f1$measured), ymin = 0), colour = &quot;grey19&quot;, size = 1) #Order the layers so that p2 and p3 are beneath p1 p1$layers &lt;- c(p2, p3, p1$layers) #Limit the x-axis to between 25 and 30 degrees so that the #dominant features can be easily examned p1 &lt;- p1 + scale_x_continuous(limits = c(25, 30)) p1 Figure 3.11: Combining the results from full pattern summation with the features selected by Cubist for prediction of K concentrations. To make the data in Figure 3.11 interactive, its possible to use the ggplotly() function of the plotly package via: library(plotly) ggplotly(p1) From these plots (in particular the interactive version), it is possible to infer that the variables selected by Cubist in this region are specifically related to K-feldspar contributions to the diffraction data. K-feldspar minerals represent the major K-reserves in most soils and this selection by Cubist is therefore completely appropriate. Further mineral sources of other nutrients and micronutrients within this or other datasets can be inferred in a similar manner. References "],["cluster-analysis.html", "Chapter 4 Cluster analysis of soil XRPD data 4.1 Loading data 4.2 Principal component analysis", " Chapter 4 Cluster analysis of soil XRPD data Benjamin Butler This chapter will demonstrate the use of cluster analysis to identify mineral-nutrient relationships in African soils. The examples provided for the cluster analysis use the data presented in Butler et al. (2020) that is hosted here on Mendeley Data. To run the examples in this chapter on your own machine, you will need to download the soil property data in .csv format and the XRPD data in a zipped folder of xy files. Please simply save these files to your own directory, and unzip the zipped folder containing the .xy files. Skip this step if you have already downloaded these files for the examples in Chapter 3, Download soil property csv Download zipped XRPD data 4.1 Loading data Once you have downloaded the data required for this chapter, it can be loaded into R by modifying the paths in the following code: library(powdR) #Load the soil property data props &lt;- read.csv(file = &quot;path/to/your/file/clusters_and_properties.csv&quot;) #Load the XRPD data #Get the full file paths xrpd_paths &lt;- dir(&quot;path/to/xrd&quot;, full.names = TRUE) #Load the data xrpd &lt;- read_xy(files = xrpd_paths) 4.2 Principal component analysis The cluster analysis in this Chapter is applied to principal components of soil XRPD data derived using Principal Component Analysis (PCA; Jolliffe (1986)). Prior to applying cluster analysis to the XRPD data via this approach, it is important to apply corrections for sample-independent variation such as small \\(2\\theta\\) misalignments and/or fluctuations in count intensities. For this example, the pre-treatment routine will be based on that defined in Butler et al. (2020), and will involve alignment, subsetting, square root transformation and mean centering. Together these correct for common experimental aberrations so that the variation in the observed data is almost entirely sample-dependent. The pre-treatment steps used here also match those described in Section @ref(#cubist-pretreatment), excepted for the additional step of square root transforming the data, which acts to reduced the relative intensity of quartz peaks that can often dominate the overall variation in diffraction data. Alignment of the data can be carried out using the align_xy() function outlined above, which aligns each sample within the dataset to a pure quartz pattern: #load the rockjock data data(rockjock) #Extract a quartz pattern from rockjock quartz &lt;- as_xy(data.frame(rockjock$tth, rockjock$xrd$QUARTZ)) #Align the xrpd data to this quartz pattern #using a restricted 2theta range of 10 to 60 xrpd_aligned &lt;- align_xy(xrpd, std = quartz, xmin = 10, xmax = 60, xshift = 0.2) Aligned data can then be subset to \\(2\\theta\\) &gt; 6 so that the high background at low angles in the data can be removed. subset_xrpd &lt;- function (x, xmin) { x &lt;- x[x[[1]] &gt;= xmin, ] return(x) } xrpd_aligned &lt;- lapply(xrpd_aligned, subset_xrpd, xmin = 6) Following alignment, the remaining data pre-treatment steps (square root transform and mean centering) and PCA can be carried out in a single step using the xrpd_pca() function in powdR: pca &lt;- xrpd_pca(xrpd_aligned, mean_center = TRUE, root_transform = 2, components = 10) #View the variance explained by the first 10 PCs pca$eig[1:10,] ## eigenvalue variance.percent cumulative.variance.percent ## Dim.1 32315.9160 81.3717652 81.37177 ## Dim.2 2075.7930 5.2268653 86.59863 ## Dim.3 1069.7986 2.6937624 89.29239 ## Dim.4 742.7063 1.8701411 91.16253 ## Dim.5 611.8038 1.5405275 92.70306 ## Dim.6 418.6753 1.0542281 93.75729 ## Dim.7 388.2599 0.9776419 94.73493 ## Dim.8 214.5578 0.5402586 95.27519 ## Dim.9 182.8921 0.4605239 95.73571 ## Dim.10 144.1440 0.3629558 96.09867 From which it can be seen that the first 10 principal components (PCs) of the data account for 96 % of variation in the XRPD data. The resulting cluster analysis will therefore be based upon these 10 components. For simplicity this example will use the first 5 PCs hereafter, which together account for 93 % of total variation. library(gridExtra) library(ggplot2) #Define the x-axis components x &lt;- c(1, 1, 1, 1, 2, 2, 2, 3, 3, 4) #Define the y-axis components y &lt;- c(2, 3, 4, 5, 3, 4, 5, 4, 5, 5) #Create and empty list p &lt;- list() #Populate each item in the list using the dimension defined #in x and y for (i in 1:length(x)) { p[[i]] &lt;- ggplot(data = pca$coords) + geom_point(aes_string(x = paste0(&quot;Dim.&quot;, x[i]), y = paste0(&quot;Dim.&quot;, y[i])), shape = 21, size = 3) } grid.arrange(grobs = p, ncol = 2) Figure 4.1: The first 5 PCs plotted against one-another References "],["references.html", "References", " References "]]
