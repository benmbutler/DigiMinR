[["index.html", "Digital Soil Mineralogy with R Preface Prerequisites Code Conventions What to expect About the authors Acknowledgments", " Digital Soil Mineralogy with R Benjamin Butler and Steve Hillier 2021-08-27 Preface Digital Soil Mineralogy relates to the data-driven analysis of soil X-ray powder diffraction (XRPD) data. Such data are considered to be precise digital signatures of a given soils mineralogy, within which is all of the information required to identify and quantify the various mineral components within these complex mixtures. In recent years various methods for Digital Soil Mineralogy have been developed and published in peer-reviewed literature. These methods include the use of supervised and unsupervised machine learning to predict and interpret soil properties from XRPD data, the application of novel multivariate statistical methods, and automated approaches for mineral quantification. Each chapter in this documentation will detail one such method, providing code and data for reproducible examples that can be adapted by readers for their own projects/research. Whilst all data and methods presented herein relate to soil samples, the methods can be considered transferable to all aspects of environmental mineralogy and beyond! Prerequisites To run the examples provided throughout this document, it is recommended that you have R and RStudio installed on your machine. Once thats set up, then additional extensions (packages) required along the way can be installed and loaded. R and its extensions are designed to be multi-platform so all material presented here should work on Windows, Mac, or Linux. The only package needed from the very start of the document is powdR, and subsequent packages will be introduced in later chapters. To install powdR, use: install.packages(&quot;powdR&quot;) Code Conventions This document contains many chunks of R code that provide reproducible examples that can be copied and pasted to run on your own computer, for instance: #Summarise a vector of integers 1 to 10 summary(1:10) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.00 3.25 5.50 5.50 7.75 10.00 The R session information when compiling this book is shown below: sessionInfo() ## R version 4.1.0 (2021-05-18) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 17763) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=English_United Kingdom.1252 ## [2] LC_CTYPE=English_United Kingdom.1252 ## [3] LC_MONETARY=English_United Kingdom.1252 ## [4] LC_NUMERIC=C ## [5] LC_TIME=English_United Kingdom.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.22 codetools_0.2-18 digest_0.6.27 R6_2.5.0 ## [5] jsonlite_1.7.2 magrittr_2.0.1 evaluate_0.14 highr_0.9 ## [9] stringi_1.7.3 rlang_0.4.11 rstudioapi_0.13 jquerylib_0.1.4 ## [13] bslib_0.2.5.1 rmarkdown_2.10 tools_4.1.0 stringr_1.4.0 ## [17] xfun_0.25 yaml_2.2.1 compiler_4.1.0 htmltools_0.5.1.1 ## [21] knitr_1.33 sass_0.4.0 Text outputs associated with R code are denoted by two hashes (##) by default, as you can see from the example above. This is for your convenience when you want to copy and run the code (the text output will be ignored since it is commented out). Package names are in bold text (e.g. powdR), and inline code and filenames are formatted in a typewriter font (e.g., summary(1:10)). Function names can easily be identified by the parentheses that follow them (e.g., mean(1:10)). What to expect This document is divided into chapters that each detail specific aspects of Digital Soil Mineralogy. To start with, the basics of handling XRPD data in R are introduced, which progresses to more advanced manipulation of such data that cannot be realised with proprietary XRPD software. Subsequently, specific examples of methods for Digital Soil Mineralogy are provided that include high throughput quantitative analysis, data mining, and cluster analysis. As such, the documentation is separated into the following chapters: Chapter 1: Loading and handling XRPD data in R Chapter 2: Quantitative analysis of XRPD data using full pattern summation Chapter 3: The use of machine learning to predict and interpret soil properties from XRPD data Chapter 4: The application of cluster analysis to identify discrete groups of soils based on mineralogy Chapter 5: Identifying soils analogues for Martian mineralogy based on XRPD data Each chapter contains reproducible R code along with written explanations. For those that prefer video tutorials, there are a number of embedded YouTube videos throughout the course material that describe and explain the R code. With exception to Chapter 1, all chapters are standalone so there is no need to read everything! About the authors Benjamin Butler is a Digital Mineralogist at the James Hutton Institute, Aberdeen, UK. His interests centre around the use of XRPD to characterise the mineral composition of environmental mixtures such as soils, construction and demolition waste, and sea ice. As an active R user he has authored the powdR package that provides a range of methods for quantitative analysis of XRPD data using full pattern summation. Aside from dealing with data, he is involved in regular soil surveys on forestry land across Scotland, allowing him to observe soils from the digging to the databases. Steve Hillier is a Soil Mineralogist at the James Hutton Institute, Aberdeen, UK Acknowledgments The research that comprises the bulk of this material, and the time required to create this material was kindly funded by the Macaulay Development Trust. The support of the Scottish Government. The support of the Scottish Governments Rural and Environment Science and Analytical Services Division (RESAS) is also gratefully acknowledged. "],["intro.html", "Chapter 1 Working with XRPD data in R 1.1 The basic form of XRPD data 1.2 Loading XRPD data 1.3 Plotting XRPD data 1.4 Manipulating XRPD data", " Chapter 1 Working with XRPD data in R At this stage it is assumed that you have R and RStudio installed on your computer and have installed the powdR package using install.packages(\"powdR\"). For brief introductions to R, the RStudio website has links to useful material. One aspect worth noting is that any R function used throughout this document will have additional help associated with it that can be accessed using ?. For example, to access help on the mean() function, use ?mean. This chapter will work through: The basic form of XRPD data Loading XRPD data in R Plotting XRPD data Manipulating XRPD data 1.1 The basic form of XRPD data In its most basic form, XRPD data (a diffractogram) is simply comprised of an x-axis (2 and y-axis (counts). The following figure shows a diffratogram for a soil from north east Scotland. ## Warning: package &#39;powdR&#39; was built under R version 4.1.1 Figure 1.1: A diffractogram of a soil developed from Granite in north east Scotland Each mineral contributing to the observed diffractogram contributes peaks at specific locations along the x-axis, each with characteristic relative intensities to one-another that are defined by the crystal structure and chemistry. Each mineral can therefore be considered to have a unique signature. For quartz, an omnipresent mineral in the worlds soils, this signature is relatively simple: Figure 1.2: A diffractogram of quartz whereas other soil minerals such as K-feldspar have very different peak positions and relative intensities that again are governed by the minerals crystal structure and chemistry: Figure 1.3: A diffractogram of K-feldspar (orthoclase) In any given diffractogram there can be multiple minerals contributing their unique signature to the observed pattern, which ends up simply being the sum of these signatures each scaled by different amounts (scaling factors). These scaling factors are inherently related to a given minerals concentration within the mixture based on the defined diffracting power of each mineral, known as Reference Intensity Ratios (see Chapter 2). Together these principles make XRPD the most widely used analytical technique for qualitative and quantitative soil mineralogy. 1.2 Loading XRPD data In order to work with XRPD data in R, it first needs to be loaded. XRPD data come in all sorts of proprietary formats (e.g. .raw, .dat and .xrdml), which can make this initial stage of loading data more complicated than it needs to be. As described above, XRPD data is most simply comprised of an x-axis (2) and y-axis (counts), and all XRPD data loaded into R throughout this documentation will hence take this XY form. Here 2 options for loading proprietary XRPD data into R will be described. 1.2.1 Option 1: PowDLL The free software PowDLL written by Nikoloas Kourkoumelis, offers excellent functionality for the conversion of different XRPD file types. PowDLL can import and export a large range of XRPD file types including .xy files that can readily be loaded into R or any text editor. These .xy files are an ASCII format that simply comprises the two variables (2 and counts) separated by a space. The following video from Phys Whiz on YouTube illustrates use of powDLL to create the .xy files that we seek to use. Once you have your .xy files, they can be loaded into R using the read_xy() function from the powdR package. The following reproducible example uses files that are stored within powdR and were recorded on a Siemens D5000 using Co-K\\(\\alpha\\) radiation. #load the powdR package library(powdR) #Extract the path of the file from the powdR package file &lt;- system.file(&quot;extdata/D5000/xy/D5000_1.xy&quot;, package = &quot;powdR&quot;) #Load the file as an object called xy1 xy1 &lt;- read_xy(file) #Explore the xy data summary(xy1) ## tth counts ## Min. : 2.00 Min. : 70.0 ## 1st Qu.:20.25 1st Qu.: 145.0 ## Median :38.50 Median : 236.0 ## Mean :38.50 Mean : 292.9 ## 3rd Qu.:56.75 3rd Qu.: 342.0 ## Max. :75.00 Max. :6532.0 #check the class of xy data class(xy1) ## [1] &quot;XY&quot; &quot;data.frame&quot; Notice how the class of xy1 is both XY and data.frame. This means that various additional methods for each of these types of object classes can be used to explore and analyse the data. These methods can be viewed using: methods(class = &quot;XY&quot;) ## [1] align_xy interpolate plot ## see &#39;?methods&#39; for accessing help and source code which shows how functions align_xy(), interpolate() and plot() all have methods for XY class objects. Help on each of these can be sourced using ?align_xy.XY, ?interpolate.XY and ?plot.XY, respectively. When calling these functions it is not necessary to specify the .XY suffix because R will recognise the class and call the relevant method. 1.2.2 Option 2: Loading directly into R Alternatively to PowDLL, the extract_xy() function in the powdR package can extract the XY data from a wide range of proprietary XRPD file formats straight into R via the xylib C++ library implemented behind the scenes in the rxylib package (Kreutzer and Johannes Friedrich 2020). #Extract the path of the file from the powdR package file &lt;- system.file(&quot;extdata/D5000/RAW/D5000_1.RAW&quot;, package = &quot;powdR&quot;) #Load the file as an object called xy2 xy2 &lt;- extract_xy(file) ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected #Summarise the xy data summary(xy2) ## tth counts ## Min. : 2.00 Min. : 70.0 ## 1st Qu.:20.25 1st Qu.: 145.0 ## Median :38.50 Median : 236.0 ## Mean :38.50 Mean : 292.9 ## 3rd Qu.:56.75 3rd Qu.: 342.0 ## Max. :75.00 Max. :6532.0 #Check the class of xy2 class(xy2) ## [1] &quot;XY&quot; &quot;data.frame&quot; A word of warning with extract_xy() is that it does not work with all proprietary file types. In particular you may experience problems with Bruker .raw files, in which case the use of PowDLL outlined above is recommended instead. 1.2.3 Loading multiple files The two approaches for loading XRPD data outlined above can also be used to load any number of files into R at once. read_xy() and extract_xy() will recognise cases where more than one file path is supplied and therefore load the files into a multiXY object. 1.2.3.1 read_xy() There are five .xy files stored within a directory of the powdR package that can be loaded into a multiXY object via: paths1 &lt;- dir(system.file(&quot;extdata/D5000/xy&quot;, package = &quot;powdR&quot;), full.names = TRUE) #Now read all files in the directory xy_list1 &lt;- read_xy(paths1) #Check the class of xy_list1 class(xy_list1) ## [1] &quot;multiXY&quot; &quot;list&quot; The resulting multiXY object is a list of XY objects, with each XY object being a data frame comprised of the 2 and count intensities of the XRPD data. #Check the class of each item within the multiXY object lapply(xy_list1, class) ## $D5000_1 ## [1] &quot;XY&quot; &quot;data.frame&quot; ## ## $D5000_2 ## [1] &quot;XY&quot; &quot;data.frame&quot; ## ## $D5000_3 ## [1] &quot;XY&quot; &quot;data.frame&quot; ## ## $D5000_4 ## [1] &quot;XY&quot; &quot;data.frame&quot; ## ## $D5000_5 ## [1] &quot;XY&quot; &quot;data.frame&quot; Each sample within the list can be accessed using the $ symbol. For example: #Summarise the data within the first sample: summary(xy_list1$D5000_1) ## tth counts ## Min. : 2.00 Min. : 70.0 ## 1st Qu.:20.25 1st Qu.: 145.0 ## Median :38.50 Median : 236.0 ## Mean :38.50 Mean : 292.9 ## 3rd Qu.:56.75 3rd Qu.: 342.0 ## Max. :75.00 Max. :6532.0 Alternatively, the same item within xy_list1 could be accessed using xy_list1[[1]]. In the same way the XY class objects have methods associated with them, there are a number of different methods for multiXY objects: methods(class = &quot;multiXY&quot;) ## [1] align_xy interpolate multi_xy_to_df plot ## see &#39;?methods&#39; for accessing help and source code which include align_xy(), interpolate(), multi_xy_to_df() and plot that are all detailed in subsequent sections. 1.2.3.2 extract_xy() In addition to the five .xy files loaded above, there are also five .RAW files stored within a separate directory of powdR, which can be loaded in a similar fashion using extract_xy(): paths2 &lt;- dir(system.file(&quot;extdata/D5000/RAW&quot;, package = &quot;powdR&quot;), full.names = TRUE) #Now read all files in the directory xy_list2 &lt;- extract_xy(paths2) ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected ## ## [read_xyData()] &gt;&gt; File of type Siemens/Bruker RAW detected #Find out what the xy_list2 is class(xy_list2) ## [1] &quot;multiXY&quot; &quot;list&quot; which yields xy_list2 that is identical to xy_list1: all.equal(xy_list1, xy_list2) ## [1] TRUE 1.3 Plotting XRPD data The powdR package contains plot() methods for both XY and multiXY objects (see ?plot.XY and ?plot.multiXY). 1.3.1 Plotting XY objects An XY object can be plotted by: plot(xy1, wavelength = &quot;Co&quot;, interactive = FALSE) Figure 1.4: An example figure created using the plot method for an XY object. where wavelength = \"Co\" is required so that d-spacings can be computed and displayed when interactive = TRUE. 1.3.2 Plotting multiXY objects Often its useful to plot more than one pattern at the same time, which can be achieved by plotting a multiXY object: plot(xy_list1, wavelength = &quot;Co&quot;, interactive = FALSE) Figure 1.5: An example figure created using the plot method for a multiXY object. As above, using interactive = TRUE in the function call will instead produce an interactive plot. In addition, the plotting of XY and multiXY objects also allows you to alter the x-axis limits and normalise the count intensities for easier comparison of specific peaks: plot(xy_list1, wavelength = &quot;Co&quot;, xlim = c(30, 32), normalise = TRUE) Figure 1.6: An example figure created using the plot method for an XY object with normalised count intensities and a restrict x-axis. 1.3.3 Modifying plots with ggplot2 All plots shown so far are produced behind the scenes using the ggplot2 package, which will already be present on your machine if you have installed powdR. This means that it is possible to modify the plots in different ways by adding subsequent ggplot2 layers, each separated by +. For example, its possible to add points of the quartz peak intensities extracted from a crystal structure database using geom_point(), and then add a title using ggtitle(), followed by changing the theme using theme_bw(). #Define the relative intensities of quartz peaks quartz &lt;- data.frame(&quot;tth&quot; = c(24.22, 30.99, 42.61, 46.12, 47.06, 49.62, 53.62, 58.86, 64.60, 65.18, 70.79, 73.68), &quot;intensity&quot; = c(0.20, 1.00, 0.06, 0.06, 0.03, 0.05, 0.03, 0.11, 0.03, 0.01, 0.07, 0.03)) #Load the ggplot2 package library(ggplot2) #Create a plot called p1 p1 &lt;- plot(xy1, wav = &quot;Co&quot;, normalise = TRUE) + geom_point(data = quartz, aes(x = tth, y = intensity), size = 5, shape = 21, colour = &quot;red&quot;) + ggtitle(&quot;A soil with quartz peaks identified&quot;) + theme_bw() p1 Figure 1.7: A quartz diffractogram with the locations and relative intensities of the quartz peaks identified. Further help on using the ggplot2 package to build up plots in layers is provided in Hadley Wickhams excellent documentation on data visualization. Plots produced using ggplot2 are static by default and can be exported as high quality images or pdfs. In some cases it is also useful to produce an interactive plot, which in the case of XRPD data allows for easy inspection of minor features. For most plots creating using ggplot2, the ggplotly() function from the plotly package can be used to convert them into interactive HTML plots that will load either in RStudio or your web browser: library(plotly) ggplotly(p1) 1.4 Manipulating XRPD data Loading XRPD data into R opens up almost limitless capabilities for analysing and manipulating the data via the R language and the thousands of open source packages that enhance its functionality. Here some common forms of XRPD data manipulation will be introduced: Subsetting Transformations of count intensities Interpolation Alignment Background fitting Converting to data frames 2 transformation 1.4.1 Subsetting XRPD data Quite often the analysis of XRPD data may be applied to a reduced 2 range compared to that measured on the diffractometer. This can readily be achieved in R for any number of samples. By summarising xy1 we can see that the 2 column has a minimum of 2 and a maximum of 75 degrees. summary(xy1) ## tth counts ## Min. : 2.00 Min. : 70.0 ## 1st Qu.:20.25 1st Qu.: 145.0 ## Median :38.50 Median : 236.0 ## Mean :38.50 Mean : 292.9 ## 3rd Qu.:56.75 3rd Qu.: 342.0 ## Max. :75.00 Max. :6532.0 If we wanted to reduce this to the range of 1060 \\(^\\circ\\) 2 then we have a couple of options. First we could extract the relevant data directly using the [,] notation for a data frame, where values before the comma represent rows and values after the comma represent columns: xy1_sub &lt;- xy1[xy1$tth &gt;= 10 &amp; xy1$tth &lt;= 60, ] summary(xy1_sub) ## tth counts ## Min. :10.0 Min. : 93.0 ## 1st Qu.:22.5 1st Qu.: 174.0 ## Median :35.0 Median : 256.0 ## Mean :35.0 Mean : 308.2 ## 3rd Qu.:47.5 3rd Qu.: 345.0 ## Max. :60.0 Max. :6532.0 This first option is quite simple, but if we wanted to apply it to a list of patterns then using the subset() function would be a far better option.: xy1_sub2 &lt;- subset(xy1, tth &gt;= 10 &amp; tth &lt;= 60) identical(xy1_sub, xy1_sub2) ## [1] TRUE When using a function like subset(), it is very easy to apply it to any number of patterns in a multiXY object or list using lapply(): xy_list1_sub &lt;- lapply(xy_list1, subset, tth &gt;= 10 &amp; tth &lt;= 60) #Similarly we can summarise the data in the list again lapply(xy_list1_sub, summary) ## $D5000_1 ## tth counts ## Min. :10.0 Min. : 93.0 ## 1st Qu.:22.5 1st Qu.: 174.0 ## Median :35.0 Median : 256.0 ## Mean :35.0 Mean : 308.2 ## 3rd Qu.:47.5 3rd Qu.: 345.0 ## Max. :60.0 Max. :6532.0 ## ## $D5000_2 ## tth counts ## Min. :10.0 Min. : 176 ## 1st Qu.:22.5 1st Qu.: 361 ## Median :35.0 Median : 469 ## Mean :35.0 Mean : 557 ## 3rd Qu.:47.5 3rd Qu.: 730 ## Max. :60.0 Max. :2094 ## ## $D5000_3 ## tth counts ## Min. :10.0 Min. : 74.0 ## 1st Qu.:22.5 1st Qu.: 154.0 ## Median :35.0 Median : 193.0 ## Mean :35.0 Mean : 240.6 ## 3rd Qu.:47.5 3rd Qu.: 251.0 ## Max. :60.0 Max. :5150.0 ## ## $D5000_4 ## tth counts ## Min. :10.0 Min. : 64 ## 1st Qu.:22.5 1st Qu.: 133 ## Median :35.0 Median : 168 ## Mean :35.0 Mean : 223 ## 3rd Qu.:47.5 3rd Qu.: 216 ## Max. :60.0 Max. :7110 ## ## $D5000_5 ## tth counts ## Min. :10.0 Min. : 51.0 ## 1st Qu.:22.5 1st Qu.: 102.0 ## Median :35.0 Median : 133.0 ## Mean :35.0 Mean : 202.3 ## 3rd Qu.:47.5 3rd Qu.: 183.0 ## Max. :60.0 Max. :6837.0 1.4.2 Transformations of count intensities As will be introduced in subsequent chapters, log and root transforms of the count intensities of XRPD data can be useful when applying data mining or machine learning methods. By writing a function these transformations can be applied to any number of patterns in just a few lines of code: #Create a function for log-transforming counts log_xrpd &lt;- function (x) { x[[2]] &lt;- log10(x[[2]]) return(x) } #apply the function to a list of XRPD data xy_list1_log &lt;- lapply(xy_list1, log_xrpd) #Plot the transformed data plot(as_multi_xy(xy_list1_log), wavelength = &quot;Cu&quot;) Figure 1.8: Log transformed XRPD data. Note how the use of x[[2]] in the function represents the second column of x. Alternatively, the form x$counts could be used but the function would fail to run if the variable name was altered in any way. 1.4.3 Interpolation Sometimes XRPD patterns within a given data set may contain a number of different 2 axes due to the measurements being carried out on different instruments or on the same instrument but with a different set-up. Direct comparison of such data requires that they are interpolated onto the same 2 axis. Here a data set containing 2 samples with different 2 axes will be created using the soils and rockjock_mixtures data that are pre-loaded within the powdR package: two_instruments &lt;- as_multi_xy(list(&quot;a&quot; = soils$granite, &quot;b&quot; = rockjock_mixtures$Mix2)) plot(two_instruments, wavelength = &quot;Cu&quot;, normalise = TRUE) Figure 1.9: Diffractograms from two different instruments. In this example, the data within the two_instruments list will be interpolated onto an artificial 2 axis called new_tth, which ranges from 10 to 60 \\(^\\circ\\) 2 with a resolution of 0.02: new_tth &lt;- seq(10, 60, 0.02) two_instruments_int &lt;- interpolate(two_instruments, new_tth) plot(two_instruments_int, wavelength = &quot;Cu&quot;, normalise = TRUE) Figure 1.10: Interpolated diffractograms from two different instruments. 1.4.4 Alignment Peak positions in XRPD data commonly shift in response to small variations in specimen height in the instrument. Even seemingly small misalignments between peaks can hinder the analysis of XRPD data (Butler et al. 2019). One approach to deal with such peak shifts is to use a mineral with essentially invariant peak positions as an internal standard (e.g. the common mineral quartz), resulting in well aligned data by adding or subtracting a fixed value to the 2 axis. The powdR package contains functionality for aligning single or multiple patterns using the align_xy() function. In the following examples, samples will be aligned to a pure quartz pattern that will be loaded from the powdR package using read_xy() #Extract the location of the quartz xy file quartz_file &lt;- system.file(&quot;extdata/minerals/quartz.xy&quot;, package = &quot;powdR&quot;) #load the file quartz &lt;- read_xy(quartz_file) #Plot the main quartz peak for pure quartz and a sandstone-derived soil plot(as_multi_xy(list(&quot;quartz&quot; = quartz, &quot;sandstone&quot; = soils$sandstone)), wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26, 27)) Figure 1.11: Unaligned diffractograms. As shown in the figure above, the main quartz peaks of these two diffraction patterns do not align. This can be corrected using align_xy(): #Align the sandstone soil to the quartz pattern sandstone_aligned &lt;- align_xy(soils$sandstone, std = quartz, xmin = 10, xmax = 60, xshift = 0.2) #Plot the main quartz peak for pure quartz and a sandstone-derived soil plot(as_multi_xy(list(&quot;quartz&quot; = quartz, &quot;sandstone aligned&quot; = sandstone_aligned)), wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26, 27)) Figure 1.12: Aligned diffractograms. In cases where multiple patterns require alignment to a given standard, align_xy() can also be applied to multiXY objects: #Plot the unaligned soils data to show misalignments plot(soils, wav = &quot;Cu&quot;, xlim = c(26, 27), normalise = TRUE) Figure 1.13: Unaligned diffractograms in a multiXY object. #Align the soils data to the quartz pattern soils_aligned &lt;- align_xy(soils, std = quartz, xmin = 10, xmax = 60, xshift = 0.2) #Plot the aligned data plot(soils_aligned, wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26, 27)) Figure 1.14: Aligned diffractograms in a multiXY object. 1.4.5 Background fitting Sometimes it is beneficial to fit and subtract the background from XRPD data. To achieve this, the powdR package includes the bkg() function which uses the peak filling method implemented in the baseline package (Liland, Almøy, and Mevik 2010). The fitting provided by the bkg() function uses four adjustable parameters that each have pre-loaded defaults (see ?bkg): #Fit a background to the sandstone-derived soil granite_bkg &lt;- bkg(soils$granite) #summarise the resulting data summary(granite_bkg) ## Length Class Mode ## tth 1693 -none- numeric ## counts 1693 -none- numeric ## background 1693 -none- numeric #Plot the data and add a square root transform to aid interpretation plot(granite_bkg) + scale_y_sqrt() Figure 1.15: Fitting a background to a soil diffractogram. The y-axis is square root transformed to aid interpretation. It is then simple to derive a background-subtracted XY object: #Calculate background subtracted count intensities sandstone_bkg_sub &lt;- as_xy(data.frame(&quot;tth&quot; = granite_bkg$tth, &quot;counts&quot; = granite_bkg$counts - granite_bkg$background)) plot(sandstone_bkg_sub, wavelength = &quot;Cu&quot;) Figure 1.16: Background subtracted diffractogram. Sometimes the default values for the adjustable parameters (see ?bkg) are not appropriate, and in such cases tuning of the parameters can be an iterative process. To help with this, there is a background fitting Shiny app that can be loaded from the powdR package using run_bkg(). This app will load in your default web browser and allows for the four adjustable parameters to be tuned to a given sample that is loaded into the app in .xy format. 1.4.6 Converting to and from data frames multiXY objects can be converted to data frames using the multi_xy_to_df() function. When using this function, all samples within the multiXY object must be on the same 2 axis, which can be ensured using the interpolate() function outlined above. #Convert xy_list1 to a dataframe xy_df1 &lt;- multi_xy_to_df(xy_list1, tth = TRUE) #Show the first 6 rows of the derived data frame head(xy_df1) ## tth D5000_1 D5000_2 D5000_3 D5000_4 D5000_5 ## 1 2.00 2230 2334 2381 2323 2169 ## 2 2.02 2012 2222 2297 2128 2021 ## 3 2.04 1950 2031 2211 2056 1929 ## 4 2.06 1828 1972 2077 1918 1823 ## 5 2.08 1715 1896 2000 1861 1757 ## 6 2.10 1603 1701 1868 1799 1673 In cases where the 2 column is not required, the use of tth = FALSE in the function call will result in only the count intensities being included in the output. Data frames that take the form of xy_df1 (i.e. that include the 2 axis) can easily be converted back to a multiXY object using as_multi_xy(): #Convert xy_df1 back to a multiXY list back_to_list &lt;- as_multi_xy(xy_df1) #Check the class of the converted data class(back_to_list) ## [1] &quot;multiXY&quot; &quot;list&quot; 1.4.7 2 transformation Laboratory XRPD data are usually collected using either Cu or Co X-ray tubes, which each have characteristic K wavelengths (e.g. Cu-K = 1.54056 Angstroms whereas Co-K = 1.78897 Angstroms). These wavelengths determine the 2 at which the conditions for diffraction are met via Braggs Law: \\[ \\begin{aligned} n\\lambda = 2d\\sin\\theta \\end{aligned} \\] where \\(n\\) is an integer describing the diffraction order, \\(\\lambda\\) is the wavelength (Angstroms) and \\(d\\) is the atomic spacing (Angstroms). In some instances it can be useful to transform the 2 axis of a given sample so that the 2 peak positions are representative of a measurement made using a different X-ray source. This can be achieved using the tth_transform() function: #Create a multiXY object for this transform example transform_eg &lt;- as_multi_xy(list(&quot;Co&quot; = xy_list1$D5000_1, &quot;Cu&quot; = soils$sandstone)) #Plot two patterns recorded using different wavelengths plot(transform_eg, wavelength = &quot;Cu&quot;, normalise = TRUE, interactive = FALSE) Figure 1.17: Data obtained from Co and Cu X-ray tubes prior to 2theta transformation. #transform the 2theta of the &quot;Co&quot; sample to &quot;Cu&quot; transform_eg$Co$tth &lt;- tth_transform(transform_eg$Co$tth, from = 1.78897, to = 1.54056) #Replot data after transformation plot(transform_eg, wavelength = &quot;Cu&quot;, normalise = TRUE, interactive = FALSE) Figure 1.18: Data obtained from Co and Cu X-ray tubes after 2theta transformation. Note how prior to the 2 transformation, the dominant peaks in each pattern (associated with quartz in both cases) do not align. After the 2 transformation the peaks are almost aligned, with a small additional 2 shift that could be computed using the align_xy() function outlined above. Whilst Cu and Co are the most common X-ray sources for laboratory diffractometers, tth_transform() can accept any numeric wavelength value. References "],["quant.html", "Chapter 2 Quantitative phase analysis 2.1 Full pattern summation with powdR 2.2 Plotting powdRfps and powdRafps objects 2.3 Quantifying multiple samples 2.4 Summarising mineralogy 2.5 The powdR Shiny app", " Chapter 2 Quantitative phase analysis This chapter describes methods for quantitative analysis implemented within the powdR package using a range of reproducible examples. Detailed accounts of these methods are provided in Butler and Hillier (2021a) and Butler and Hillier (2021b). One of the most powerful properties of XRPD data is that the intensities of crystalline (e.g., quartz, calcite and gypsum), disordered (e.g., clay minerals), and amorphous (e.g., volcanic glass and organic matter) signals within a diffractogram can be related to their concentrations within the mixture. This principal facilitates the quantification of phase concentrations from XRPD data. Of the approaches available for quantitative XRPD, the simple Reference Intensity Ratio (RIR) method has consistently proven accurate. A RIR is a measure of the diffracting power of a phase relative to that of a standard (most often corundum, Al2O3), usually measured in a 50:50 mixture by weight. The RIR of a detectable phase within a mixture is required for its quantification. As mentioned in Chapter 1, a given diffractogram can be modeled as the sum of pure diffractograms for all detectable phases, each scaled by different amounts (scaling factors). By combining these scaling factors with RIRs, phase concentrations can be calculated. Hereafter this approach is referred to as full pattern summation. Full pattern summation is particularly suitable for mixtures containing crystalline mineral components in combination with disordered and/or X-ray amorphous phases. Soil is a prime example of such mixtures, where crystalline minerals such as quartz and feldspars can be present in combination with clay minerals (i.e. disordered phases), and organic matter (i.e. amorphous phases). A key component of the full pattern summation approach is the reference library containing measured or calculated patterns of the pure phases that may be encountered within the samples. The reference patterns within the library would ideally be measured on the same instrument as the sample, however in some cases this isnt possible and the data can be harmonised accordingly. To quantify a given sample, suitable phases from the library are selected that together account for the peaks within the data, and their relative contributions to the observed signal optimised until an appropriate fit is achieved. This fit is usually refined using least squares optimisation of an objective parameter. The scaled intensities of the optimised patterns are then converted to weight % using the RIRs (see Section 2 in Butler and Hillier 2021a). 2.1 Full pattern summation with powdR 2.1.1 The powdRlib object A key component of the full pattern summation functions within powdR is the library of reference patterns. These are stored within a powdRlib object created from two basic components using the powdRlib() constructor function. The first component, specified via the xrd_table argument of powdRlib(), is a data frame of the count intensities of the reference patterns, with their 2 axis as the first column. The column for a given reference pattern must be named using a unique identifier (a phase ID). An example of such a format is provided in the minerals_xrd data: library(powdR) data(minerals_xrd) head(minerals_xrd) ## tth QUA.1 QUA.2 FEL ORT SAN ALB OLI DOL.1 DOL.2 ILL KAO GOE.1 GOE.2 ORG ## 1 4.00973 69 91 546 599 638 308 343 268 362 3078 525 3549 10000 3225 ## 2 4.04865 69 92 524 570 609 294 332 256 345 2960 500 3511 9592 3180 ## 3 4.08757 64 86 505 555 582 286 328 250 343 2888 486 3401 9323 3135 ## 4 4.12649 64 83 512 543 558 277 310 247 327 2753 474 3290 9042 3092 ## 5 4.16541 62 83 478 518 536 275 304 241 318 2718 478 3194 9248 3050 ## 6 4.20433 60 81 459 514 517 261 298 228 314 2720 447 3113 8557 3010 The second component required to build a powdRlib object, specified via the phases_table argument of powdRlib(), is a data frame containing 3 columns. The first column is a string of unique IDs corrensponding to the names of each reference pattern in the data provided to the xrd_table argument outlined above. The second column is the name of the phase group that this reference pattern belongs to (e.g. quartz, plagioclase, Illite etc). The third column is the reference intensity ratio (RIR) of that reference pattern (relative to a known standard, usually corundum). An example of the format required for the phases_table argument of powRlib() is provided in the minerals_phases data. data(minerals_phases) minerals_phases ## phase_id phase_name rir ## 1 QUA.1 Quartz 4.62 ## 2 QUA.2 Quartz 4.34 ## 3 FEL K-feldspar 0.75 ## 4 ORT K-feldspar 1.03 ## 5 SAN K-feldspar 0.93 ## 6 ALB Plagioclase 1.31 ## 7 OLI Plagioclase 1.06 ## 8 DOL.1 Dolomite 2.35 ## 9 DOL.2 Dolomite 2.39 ## 10 ILL Illite 0.22 ## 11 KAO Kaolinite 0.91 ## 12 GOE.1 Goethite 0.93 ## 13 GOE.2 Goethite 0.37 ## 14 ORG Organic-Matter 0.07 Crucially when building the powdRlib object, all phase IDs in the first column of the phases_table must match the column names of the xrd_table (excluding the name of the first column which is the 2 axis), for example. identical(names(minerals_xrd[-1]), minerals_phases$phase_id) ## [1] TRUE Once created, powdRlib objects can easily be visualised using the associated plot() method (see ?plot.powdRlib), which accepts the arguments wavelength, refs and interactive that are used to specify the X-ray wavelength, the reference patterns to plot, and the output format, respectively. In all cases where plot() is used in this chapter, the use of interactive = TRUE in the function call will produce an interactive html graph that can be viewed in RStudio or a web browser. my_lib &lt;- powdRlib(minerals_xrd, minerals_phases) plot(my_lib, wavelength = &quot;Cu&quot;, refs = c(&quot;ALB&quot;, &quot;DOL.1&quot;, &quot;QUA.1&quot;, &quot;GOE.2&quot;), interactive = FALSE) Figure 2.1: Plotting selected reference patterns from a powdRlib object. 2.1.1.1 Pre-loaded powdRlib objects There are two powdRlib objects provided as part of the powdR package. The first is minerals [accessed via data(minerals)], which is a simple and low resolution library designed to facilitate fast computation of basic examples. The second is rockjock [accessed via data(rockjock)], which is a comprehensive library of 169 reference patterns covering most phases that might be encountered in geological and soil samples. The rockjock library in powdR uses data from the original RockJock program (Eberl 2003) thanks to the permission of Dennis Eberl. In rockjock, each reference pattern from the original RockJock program has been scaled to a maximum intensity of 10000 counts, and the RIRs normalised relative to Corundum. All rockjock data were analysed using Cu K\\(\\alpha\\) radiation. The final library is afsis [accessed via data(minerals)], which contains 21 reference patterns measured on a Bruker D2 phaser as part of the XRPD data analysis undertaken for Africa Soil Information Service Sentinel Site programme. To accompany the rockjock reference library, a list of eight synthetic mixtures from the original RockJock program (Eberl 2003) are also included in powdR in the rockjock_mixtures data [accessed via data(rockjock_mixtures)], and the known compositions of these mixtures provided in the rockjock_weights data [accessed via data(rockjock_weights)]. 2.1.1.2 Subsetting a powdRlib object Occasionally it may be useful to subset a reference library to a smaller selection. This can be achieved using subset(), which for powdRlib objects accepts three arguments; x, refs and mode (see ?subset.powdRlib). The x argument specifies the powdRlib object to be subset, refs specifies the IDs and/or names of phases to select, and mode specifies whether these phases are kept (mode = \"keep\") or removed (mode = \"remove\"). data(rockjock) #Have a look at the phase ID&#39;s in rockjock rockjock$phases$phase_id[1:10] ## [1] &quot;CORUNDUM&quot; &quot;BACK_POS&quot; ## [3] &quot;BACK_NEG&quot; &quot;QUARTZ&quot; ## [5] &quot;ORDERED_MICROCLINE&quot; &quot;INTERMEDIATE_MICROCLINE&quot; ## [7] &quot;SANIDINE&quot; &quot;ORTHOCLASE&quot; ## [9] &quot;ANORTHOCLASE&quot; &quot;ALBITE_CLEAVELANDITE&quot; #Remove reference patterns from rockjock rockjock_1 &lt;- subset(rockjock, refs = c(&quot;ALUNITE&quot;, #phase ID &quot;AMPHIBOLE&quot;, #phase ID &quot;ANALCIME&quot;, #phase ID &quot;Plagioclase&quot;), #phase name mode = &quot;remove&quot;) #Check number of reference patterns remaining in library nrow(rockjock_1$phases) ## [1] 157 #Keep certain reference patterns of rockjock rockjock_2 &lt;- subset(rockjock, refs = c(&quot;ALUNITE&quot;, #phase ID &quot;AMPHIBOLE&quot;, #phase ID &quot;ANALCIME&quot;, #phase ID &quot;Plagioclase&quot;), #phase name mode = &quot;keep&quot;) #Check number of reference patterns remaining nrow(rockjock_2$phases) ## [1] 11 2.1.1.3 Interpolating and merging powdRlib objects Two powdRlib objects from different instruments can be interpolated and then merged using the interpolate and merge methods (see ?interpolate.powdRlib and merge.powdRlib), respectively. For example, the minerals library can be merged with the rockjock library following interpolation using: #Load the minerals library data(minerals) #Check the number of reference patterns nrow(minerals$phases) ## [1] 14 #Check the number of reference patterns in rockjock nrow(rockjock$phases) ## [1] 168 #interpolate minerals library onto same 2theta as rockjock minerals_i &lt;- interpolate(minerals, new_tth = rockjock$tth) #merge the libraries merged_lib &lt;- merge(rockjock, minerals_i) #Check the number of reference patterns in the merged library nrow(merged_lib$phases) ## [1] 182 In simpler cases where two libraries are already on the same 2 axis and were measured using the same instrumental parameters, only the use of merge() would be required. #Load the afsis library data(afsis) identical(rockjock$tth, afsis$tth) ## [1] TRUE rockjock_afsis &lt;- merge(rockjock, afsis) 2.1.2 Full pattern summation with fps() Once you have a powdRlib reference library and diffractogram(s) loaded into R, you have everything needed for quantitative analysis via full pattern summation. Full pattern summation in powdR is provided via the fps() function, whilst an automated version is provided in afps(). Details of the equations and routines implemented in fps() and afps() are provided in Butler and Hillier (2021a) and Butler and Hillier (2021b). fps() is specifically applied to powdRlib objects, and accepts a wide range of arguments that are detailed in the package documentation (see ?fps.powdRlib). Here the rockjock and rockjock_mixtures data will be used to demonstrate the main features of fps() and the various ways in which it can be used. 2.1.2.1 Full pattern summation with an internal standard Often samples are prepared for XRPD analysis with an internal standard of known concentration. If this is the case, then the std and std_conc arguments of fps() can be used to define the internal standard and its concentration (in weight %), respectively, which is then used in combination with the reference intensity ratios to compute phase concentrations. For example, all samples in the rockjock_mixtures data were prepared with 20 % corundum as the internal standard, thus this can be specified using std = \"CORUNDUM\" and std_conc = 20 in the call to fps(). In addition, setting the omit_std argument to TRUE makes sure that the internal standard concentration will be omitted from the output and the phase concentrations recomputed accordingly. In such cases the phase specified as the internal standard can also be used in combination with the value specified in the align argument to ensure that the measured diffractogram is appropriately aligned on the 2 axis using the alignment approach outlined above. These principles are used in the example below, which passes the following seven arguments to fps(): lib is used to define the powdRlib object containing the reference patterns and their RIRs. smpl is used to defined the data frame or XY object containing the sample diffractogram. refs is used to define a string of phase IDs (lib$phases$phase_id) and/or phase names (lib$phases$phase_names) of the reference patterns to be used in the fitting process. std is used to define the phase ID of the reference pattern to be used as the internal standard. std_conc is used to define the concentration of the internal standard in weight %. omit_std is used to define whether the internal standard is omitted from the output and phase concentrations recomputed accordingly. align is used to define the maximum positive or negative shift in 2 that is permitted during alignment of the sample to the reference pattern that is specified in the std argument. data(rockjock_mixtures) fit1 &lt;- fps(lib = rockjock, smpl = rockjock_mixtures$Mix1, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;Plagioclase&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;), std = &quot;CORUNDUM&quot;, std_conc = 20, omit_std = TRUE, align = 0.3) ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Removing negative coefficients and reoptimising... ## -Computing phase concentrations ## -Using internal standard concentration of 20 % to compute phase concentrations ## -Omitting internal standard from phase concentrations ## ***Full pattern summation complete*** Once computed, the fps() function produces a powdRfps object, which is a bundle of data in list format that contains the outputs (see ?fps.powdRlib). summary(fit1) ## Length Class Mode ## tth 2989 -none- numeric ## fitted 2989 -none- numeric ## measured 2989 -none- numeric ## residuals 2989 -none- numeric ## phases 4 data.frame list ## phases_grouped 2 data.frame list ## obj 3 -none- numeric ## weighted_pure_patterns 7 data.frame list ## coefficients 7 -none- numeric ## inputs 16 -none- list The phase concentrations can be accessed in the phases data frame of the powdRfps object: fit1$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Corundum 1.0000000 NA ## 2 ORDERED_MICROCLINE K-feldspar 0.9654312 3.777500 ## 3 ANDESINE Plagioclase 0.8206422 4.660500 ## 4 LABRADORITE Plagioclase 0.8113040 20.397000 ## 5 KAOLINITE_DRY_BRANCH Kaolinite 0.5812875 14.654375 ## 6 ILLITE_1M_RM30 Illite 0.2768664 7.666375 ## 7 MONTMORILLONITE_WYO Smectite (Di) 0.3202779 50.955000 Further, notice that if the concentration of the internal standard is specified then the phase concentrations do not necessarily sum to 100 %: sum(fit1$phases$phase_percent, na.rm = TRUE) ## [1] 102.1108 Unlike other software where only certain phases can be used as an internal standard, any phase can be defined in powdR. For example, the rockjock_mixtures$Mix5 sample contains 20 % quartz (see data(rockjock_weights)), thus adding \"QUARTZ\" as the std argument results in this reference pattern becoming the internal standard instead. fit2 &lt;- fps(lib = rockjock, smpl = rockjock_mixtures$Mix5, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;Plagioclase&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;CORUNDUM&quot;, &quot;QUARTZ&quot;), std = &quot;QUARTZ&quot;, std_conc = 20, omit_std = TRUE, align = 0.3) ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Removing negative coefficients and reoptimising... ## -Computing phase concentrations ## -Using internal standard concentration of 20 % to compute phase concentrations ## -Omitting internal standard from phase concentrations ## ***Full pattern summation complete*** fit2$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Corundum 1.0000000 24.893750 ## 2 QUARTZ Quartz 3.5404393 NA ## 3 ORDERED_MICROCLINE K-feldspar 0.9654312 39.810500 ## 4 ANORTHOCLASE Plagioclase 0.5804293 3.597250 ## 5 ANDESINE Plagioclase 0.8206422 2.626125 ## 6 LABRADORITE Plagioclase 0.8113040 3.474375 ## 7 ANORTHITE Plagioclase 0.5294816 2.744125 ## 8 KAOLINITE_DRY_BRANCH Kaolinite 0.5812875 5.332125 ## 9 MONTMORILLONITE_WYO Smectite (Di) 0.3202779 12.902250 sum(fit2$phases$phase_percent, na.rm = TRUE) ## [1] 95.3805 Its also possible to close the mineral composition so that the weight percentages sum to 100. This can be achieved in two ways: By defining closed = TRUE in the fps() function call. By applying the close_quant() function to the powdRfps output. For example, the phase composition in fit2 created above can be closed using: fit2c &lt;- close_quant(fit2) sum(fit2c$phases$phase_percent, na.rm = TRUE) ## [1] 100 2.1.2.2 Full pattern summation without an internal standard In cases where an internal standard is not added to a sample, phase quantification can be achieved by assuming that all detectable phases can be identified and that they sum to 100 weight %. By setting the std_conc argument of fps() to NA, or leaving it out of the function call, it will be assumed that the sample has been prepared without an internal standard and the phase concentrations computed accordingly. fit3 &lt;- fps(lib = rockjock, smpl = rockjock_mixtures$Mix1, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;Plagioclase&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;), std = &quot;CORUNDUM&quot;, align = 0.3) ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Removing negative coefficients and reoptimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** In this case the phase specified in the std argument is only used for 2 alignment, and is always included in the computed phase concentrations. fit3$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Corundum 1.0000000 19.6679 ## 2 ORDERED_MICROCLINE K-feldspar 0.9654312 2.9718 ## 3 ANDESINE Plagioclase 0.8206422 3.6665 ## 4 LABRADORITE Plagioclase 0.8113040 16.0466 ## 5 KAOLINITE_DRY_BRANCH Kaolinite 0.5812875 11.5288 ## 6 ILLITE_1M_RM30 Illite 0.2768664 6.0313 ## 7 MONTMORILLONITE_WYO Smectite (Di) 0.3202779 40.0871 Furthermore, the phase concentrations computed using this approach will always sum to 100 %. sum(fit3$phases$phase_percent) ## [1] 100 2.1.2.3 Full pattern summation with data harmonisation It is usually recommended that the reference library used for full pattern summation is measured on the same instrument as the sample using an identical 2 range and resolution. In some cases this is not feasible, and the reference library patterns may be from a different instrument to the sample. To allow for seamless use of samples and libraries from different instruments (measured using the same X-ray wavelength), fps() contains a logical harmonise argument (default = TRUE). When the sample and library contain non-identical 2 axes, harmonise = TRUE will convert the data onto the same axis by determining the overlapping 2 range and interpolating to the coarsest resolution available. #Create a sample with a shorter 2theta axis than the library Mix1_short &lt;- subset(rockjock_mixtures$Mix1, tth &gt; 10 &amp; tth &lt; 55) #Reduce the resolution by selecting only odd rows of the data Mix1_short &lt;- Mix1_short[seq(1, nrow(Mix1_short), 2),] fit4 &lt;- fps(lib = rockjock, smpl = Mix1_short, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;Plagioclase&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;), std = &quot;CORUNDUM&quot;, align = 0.3) ## ## -Harmonising library to the same 2theta resolution as the sample ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Removing negative coefficients and reoptimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** fit4$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Corundum 1.0000000 19.5826 ## 2 ORDERED_MICROCLINE K-feldspar 0.9654312 3.1967 ## 3 ANDESINE Plagioclase 0.8206422 4.2983 ## 4 LABRADORITE Plagioclase 0.8113040 16.4326 ## 5 ANORTHITE Plagioclase 0.5294816 0.1007 ## 6 KAOLINITE_DRY_BRANCH Kaolinite 0.5812875 12.9506 ## 7 ILLITE_1M_RM30 Illite 0.2768664 8.1800 ## 8 MONTMORILLONITE_WYO Smectite (Di) 0.3202779 35.2585 2.1.3 Automated full pattern summation with afps() The selection of suitable reference patterns for full pattern summation can often be challenging and time consuming. An attempt to automate this process is provided in the afps() function, which can select appropriate reference patterns from a reference library and subsequently exclude reference patterns based on limit of detection estimates. Such an approach is considered particularly advantageous when quantifying high-throughput XRPD datasets that display considerable mineralogical variation such as the Reynolds Cup. Detailed accounts of the afps() function are provided in Butler and Hillier (2021a) and Butler and Hillier (2021b). All of the principles and arguments outlined above for the fps() function apply to the use of afps(). When using afps(), there are a few additional arguments that need to be defined: force is used to specify phase IDs (lib$phases$phase_id) or phase names (lib$phases$phase_name) that must be retained in the output, even if their concentrations are estimated to be below the limit of detection or negative. lod is used to define the limit of detection (LOD; in weight %) of the phase specified as the internal standard in the std argument. This limit of detection for the define phase is then used in combination with the RIRs to estimate the LODs of all other phases. amorphous is used to specify which, if any, phases should be treated as amorphous. This is used because the assumptions used to estimate the LODs of crystalliane and disordered phases are not appropriate for amorphous phases. amorphous_lod is used to define the LOD (in weight %) of the phases specified in the amorphous argument. Here the rockjock library, containing 169 reference patterns, will be used to quantify one of the samples in the rockjock_mixtures data. Note that when using afps(), omission of the refs argument in the function call will automatically result in all phases from the reference library being used in the fitting process. #Produce the fit a_fit1 &lt;- afps(lib = rockjock, smpl = rockjock_mixtures$Mix1, std = &quot;CORUNDUM&quot;, align = 0.3, lod = 1) ## ## -Using all reference patterns in the library ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Applying non-negative least squares ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Calculating detection limits ## -Removing phases below detection limit ## -Reoptimising after removing crystalline phases below the limit of detection ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Automated full pattern summation complete*** Once computed, the afps function produces a powdRafps object, which is a bundle of data in list format that contains the outputs (see ?afps.powdRlib). When large libraries such a rockjock are used to quantify a given sample, the resulting output is likely contain several different reference patterns for a given mineral, for example: table(a_fit1$phases$phase_name) ## ## Background Corundum Illite K-feldspar Kaolinite ## 1 1 2 1 1 ## Plagioclase Smectite (Di) ## 3 2 Illustrates that the resulting output contains 2 reference patterns for both illite and smectite, 3 patterns for plagioclase, and 1 pattern for each of the other phases selected by afps(). This information is grouped together and summed in the phases_grouped data frame within the powdRafps object: a_fit1$phases_grouped ## phase_name phase_percent ## 1 Corundum 19.2449 ## 2 Background 0.0001 ## 3 K-feldspar 2.6398 ## 4 Plagioclase 19.2431 ## 5 Kaolinite 10.8828 ## 6 Smectite (Di) 40.0788 ## 7 Illite 7.9105 Note that the background phase in the output is simply a horizontal line that can account for shifts in background intensity, which can be useful to use in some cases. In the rockjock data, the background patterns have been given an exceptionally high RIR so that their quantified concentrations are near zero. 2.1.4 Additional fps() and afps() functionality 2.1.4.1 Shifting of reference patterns Both fps() and afps() accept a shift argument, which when set to a value greater than zero results in optimisation of a small 2 shift for each reference pattern in order to improve the quality of the fit. The value supplied to the shift argument defines the maximum (either positive or negative) shift that can be applied to each reference pattern before the shift is reset to zero. This shifting process is designed to correct for small linear differences in the peak positions of the standards relative to the sample, which may result from a combination of instrumental aberrations, mineralogical variation and/or uncorrected errors in the library patterns. Whilst it provides more accurate results, the process can substantially increase computation time. 2.1.4.2 Regrouping phases in powdRfps and powdRafps objects Occasionally it can be useful to apply a different grouping structure to the phases quantified within a powdRfps or powdRafps object. This can be achieved using the regroup function (see ?regroup.powdRfps and ?regroup.powdRafps): #Load the rockjock regrouping structure data(rockjock_regroup) #Check the first 6 rows of the data head(rockjock_regroup) ## phase_id phase_name_grouped phase_name_grouped2 ## 1 CORUNDUM Corundum Non-clay ## 2 BACK_POS Background Background ## 3 BACK_NEG Background Background ## 4 QUARTZ Quartz Non-clay ## 5 ORDERED_MICROCLINE K-feldspar Non-clay ## 6 INTERMEDIATE_MICROCLINE K-feldspar Non-clay #Regroup the data in a_fit1 using the coarsest resolution #(i.e. select columns 1 and 3 from the data) a_fit1_rg &lt;- regroup(a_fit1, rockjock_regroup[c(1,3)]) #Check the changes made to the data a_fit1_rg$phases ## phase_id phase_name rir phase_percent ## 1 CORUNDUM Non-clay 1.000000e+00 19.2449 ## 2 BACK_NEG Background 1.000000e+04 0.0001 ## 3 ORDERED_MICROCLINE Non-clay 9.654312e-01 2.6398 ## 4 ANDESINE Non-clay 8.206422e-01 3.2496 ## 5 LABRADORITE Non-clay 8.113040e-01 15.8851 ## 6 BYTOWNITE Non-clay 7.250736e-01 0.1084 ## 7 ORD_KAOLINITE Clay 6.684230e-01 10.8828 ## 8 CA_MONTMORILLONITE Clay 2.920099e-01 16.1587 ## 9 ILLITE_1M_RM30 Clay 2.768664e-01 4.9353 ## 10 MONTMORILLONITE_WYO Clay 3.202779e-01 23.9201 ## 11 ILLITE_R0_5_PERCENT_I Clay 2.620735e-01 2.9752 #Check the new grouped data a_fit1_rg$phases_grouped ## phase_name phase_percent ## 1 Background 0.0001 ## 2 Clay 58.8721 ## 3 Non-clay 41.1278 2.2 Plotting powdRfps and powdRafps objects Plotting results powdRfps and powdRafps objects, derived from fps() and afps(), respectively, is achieved using plot() (see ?plot.powdRfps and ?plot.powdRafps). plot(a_fit1, wavelength = &quot;Cu&quot;, interactive = FALSE) Figure 2.2: Example output from plotting a powdRfps or powdRafps object. When plotting powdRfps or powdRafps objects the wavelength must be defined because it is required to compute d-spacings that are shown when interactive = TRUE. As with other plotting methods outlined in Section 1.3, interactive ggplotly() outputs can be created using interactive = TRUE. In addition to above, plotting for powdRfps and powdRafps objects can be further adjusted by the group, mode and xlim arguments. When the group argument is set to TRUE, the patterns within the fit are grouped and summed according to phase names, which can help simplify the plot: plot(a_fit1, wavelength = &quot;Cu&quot;, group = TRUE, interactive = FALSE) Figure 2.3: Plotting a powdRfps or powdRafps object with the reference patterns grouped. The mode argument can be one of \"fit\" (the default), \"residuals\" or \"both\", for example: plot(a_fit1, wavelength = &quot;Cu&quot;, mode = &quot;residuals&quot;, interactive = FALSE) Figure 2.4: Plotting the residuals of a powdRfps or powdRafps object. or alternatively both the fit and residuals can be plotted using mode = \"both\" and the 2 axis restricted using the xlim argument: plot(a_fit1, wavelength = &quot;Cu&quot;, mode = &quot;both&quot;, xlim = c(20,30), interactive = FALSE) Figure 2.5: Plotting both the fit and residuals of a powdRfps or powdRafps object. 2.3 Quantifying multiple samples 2.3.1 lapply() The simplest way to quantify multiple samples via either fps() and afps() is by wrapping either of the functions in lapply() and supplying a list of diffractograms. The following example wraps the fps() function in lapply and applies the function to the first three items within the rockjock_mixtures data. multi_fit &lt;- lapply(rockjock_mixtures[1:3], fps, lib = rockjock, std = &quot;CORUNDUM&quot;, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;LABRADORITE&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;, &quot;QUARTZ&quot;), align = 0.3) ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** ## ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** When using lapply in this way, the names of the items within the list or multiXY object supplied to the function are inherited by the output: identical(names(rockjock_mixtures[1:3]), names(multi_fit)) ## [1] TRUE 2.3.2 Parallel processing Whilst lapply is a simple way to quantify multiple samples, the computation remains restricted to a single core. Computation time can be reduced many-fold by allowing different cores of your machine to process one sample at a time, which can be achieved using the doParallel and foreach packages: #Install the foreach and doParallel package install.packages(c(&quot;foreach&quot;, &quot;doParallel&quot;)) #load the packages library(foreach) library(doParallel) #Detect number of cores on machine UseCores &lt;- detectCores() #Register the cluster using n - 1 cores cl &lt;- makeCluster(UseCores-1) registerDoParallel(cl) #Use foreach loop and %dopar% to compute in parallel multi_fit &lt;- foreach(i = 1:3) %dopar% (powdR::fps(lib = rockjock, smpl = rockjock_mixtures[[i]], std = &quot;CORUNDUM&quot;, refs = c(&quot;ORDERED_MICROCLINE&quot;, &quot;LABRADORITE&quot;, &quot;KAOLINITE_DRY_BRANCH&quot;, &quot;MONTMORILLONITE_WYO&quot;, &quot;ILLITE_1M_RM30&quot;, &quot;CORUNDUM&quot;, &quot;QUARTZ&quot;), align = 0.3)) #name the items in the aquant_parallel list names(multi_fit) &lt;- names(rockjock_mixtures)[1:3] #stop the cluster stopCluster(cl) Note how the call to fps uses the notation powdR::fps(), which specifies the accessing of the fps() function from the powdR package. 2.4 Summarising mineralogy When multiple samples are quantified it is often useful to report the phase concentrations of all of the samples in a single table. For a given list of powdRfps and/or powdRafps objects, the summarise_mineralogy() function yields such summary tables, for example: summarise_mineralogy(multi_fit, type = &quot;grouped&quot;, order = TRUE) ## sample_id Kaolinite Corundum Plagioclase Smectite (Di) Illite K-feldspar ## 1 Mix1 11.4255 19.6390 18.9222 40.2223 6.0943 3.4771 ## 2 Mix2 19.9893 20.1257 34.2955 3.1401 9.8914 7.9668 ## 3 Mix3 38.0548 20.1476 NA 3.5897 19.4220 11.0541 ## Quartz ## 1 0.2197 ## 2 4.5911 ## 3 7.7318 where type = \"grouped\" denotes that phases with the same phase_name will be summed together, and order = TRUE specifies that the columns will be ordered from most common to least common (assessed by the sum of each column). Using type = \"all\" instead would result in tabulation of all phase IDs. In addition to the quantitative mineral data, three objective parameters that summarise the quality of the fit can be appended to the table via the logical rwp, r and delta arguments. summarise_mineralogy(multi_fit, type = &quot;grouped&quot;, order = TRUE, rwp = TRUE, r = TRUE, delta = TRUE) ## sample_id Kaolinite Corundum Plagioclase Smectite (Di) Illite K-feldspar ## 1 Mix1 11.4255 19.6390 18.9222 40.2223 6.0943 3.4771 ## 2 Mix2 19.9893 20.1257 34.2955 3.1401 9.8914 7.9668 ## 3 Mix3 38.0548 20.1476 NA 3.5897 19.4220 11.0541 ## Quartz Rwp R Delta ## 1 0.2197 0.1193771 0.1165048 39834.67 ## 2 4.5911 0.1237287 0.1115322 36910.18 ## 3 7.7318 0.1141585 0.1077551 37571.72 For each of these parameters, lower values represent a smaller difference between the measured and fitted patterns, and hence are indicative of a better fit. For more information see Section 2.1 in Butler and Hillier (2021b). 2.5 The powdR Shiny app All above examples showcase the use of R code to carry out full pattern summation. It is also possible to run much of this functionality of powdR via a Shiny web application. This Shiny app can be loaded in your default web browser by running run_powdR(). The resulting application has six tabs: Reference Library Builder: Allows you to create and export a powdRlib reference library from two .csv files: one for the XRPD measurements, and the other for the ID, name and reference intensity ratio of each pattern. Reference Library Viewer: Facilitates quick inspection of the phases within a powdRlib reference library. Reference Library Editor: Allows the user to easily subset a powdRlib reference library . Full Pattern Summation: A user friendly interface for iterative full pattern summation of single samples using fps() or afps(). Results Viewer/Editor: Allows for results from previously saved powdRfps and powdRafps objects to be viewed and edited via addition or removal of reference patterns. Help Provides a series of video tutorials (via YouTube) detailing the use of the powdR Shiny application. References "],["machine-learning.html", "Chapter 3 Machine learning with soil XRPD data 3.1 Loading packages and data 3.2 Data exploration 3.3 Data pre-treatment 3.4 Creation of training and test datasets 3.5 Using Cubist 3.6 Inspection of Cubist models", " Chapter 3 Machine learning with soil XRPD data This chapter will demonstrate the use of the Cubist machine learning algorithm to predict and interpret soil properties from XRPD data. Cubist is an extension of Quinlans M5 model tree (Quinlan 1992), and is featured in the CRAN repository under the same name for use in the R statistical software environment (Kuhn and Quinlan 2021). Cubist defines a series of conditions based on predictor variables (i.e. the XRPD measurement intervals) that partition the data. At each partition there is a multivariate linear model used to predict the output (i.e. the soil property). The examples presented herein for the use of Cubist will use data from Butler et al. (2020) that is hosted on Mendeley Data here. More specifically, to run the examples in this chapter on your own machine, you will need to download the soil property data in .csv format and the XRPD data in a zipped folder of xy files. Please simply save these files to your own directory, and unzip the zipped folder containing the .xy files. Download soil property csv Download zipped XRPD data 3.1 Loading packages and data This chapter will use a number of packages that should already be installed on your machine, but will also use the leaflet and Cubist packages that may need to be installed if you have not used them before: #install packages that haven&#39;t been used on this course so far install.packages(c(&quot;leaflet&quot; and &quot;Cubist&quot;)) #load the relevant packages library(powdR) library(leaflet) library(ggplot2) library(Cubist) library(plotly) Once you have loaded the packages and downloaded the data required for this chapter, the data can be loaded into R by modifying the paths in the following code: #Load the soil property data props &lt;- read.csv(file = &quot;path/to/your/file/clusters_and_properties.csv&quot;) #Get the full file paths of the XRPD data xrpd_paths &lt;- dir(&quot;path/to/xrd&quot;, full.names = TRUE) #Load the XRPD data xrpd &lt;- read_xy(files = xrpd_paths) #Make sure the data are interpolated onto the same 2theta scale #as there are small differences within the dataset xrpd &lt;- interpolate(xrpd, new_tth = xrpd$icr030336$tth) 3.2 Data exploration The dataset used in this chapter is comprised 935 sub-soil samples from sub-Saharan Africa, sampled as part of the AfSIS Sentinel Site programme using the Land Degradation Surveillance Framework. A range of soil attributes and properties are provided in the props data, whilst each item within the xrpd data is an XY diffractogram of the soil. The names of xrpd data match the unique identifiers in the props$SSN column: #Check that the names of the xrpd data match the SSN column in props identical(names(xrpd), props$SSN) ## [1] TRUE 3.2.1 Spatial data The first 4 columns of the props data include the unique SSN identifier of each sample, the name of the Sentinel Site, and the sample location (Longitude and Latitude). Initial exploration of the spatial distribution of the dataset can be achieved using the leaflet package (Cheng, Karambelkar, and Xie 2021). A detailed guide of how to use leaflet in R is beyond the scope of this documentation, but the code used below can be adapted to produce basic plots of geo-referenced point data. leaflet maps are built up in layers similar to the principle of ggplot2 figures, with each layer being separated by a %&gt;%, which can be written in R using the Ctrl+Shift+M shortcut. leaflet(props) %&gt;% #create a leaflet object from props addTiles() %&gt;% #add the default tiles for the map surface addCircleMarkers(~Longitude, ~Latitude) Figure 3.1: Interactive map of the Sentinel Site data showing all 60 sites across sub-Saharan Africa. The map resulting from the above code shows the 60 Sentinel Sites within the dataset that together account for many of the agro-ecological regions of sub-Saharan Africa. By zooming in on the Sentinel Sites individually, it can be observed that each is comprised of a random grid of up to 16 samples within a 10 x 10 km area (Butler et al. 2020): leaflet(props[props$Sentinel_site == &quot;Bana&quot;,]) %&gt;% addTiles() %&gt;% addCircleMarkers(~Longitude, ~Latitude) Figure 3.2: Interactive map of the Bana Sentinel Site showing the sixteen sampling locations within the 10 x 10 km grid. 3.2.2 Geochemical data The props data contains a wide range of geochemical variables including pH, total organic carbon (TOC), total element concentrations (columns 9 to 15) and Mehlich-3 extractable element concentrations (columns 16 to 23). The examples provided in this chapter will focus on total concentrations of K, determined using X-ray Fluorescence (Butler et al. 2020), but the code can be easily adjusted for any other soil property within the dataset. Here the K concentration data will be summarised using the summary() function plotted as a histogram using ggplot2: #summarise the K concentration data summary(props$K) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 90.41 2482.09 7045.57 11535.65 16947.73 95674.79 #Produce a histrogram of the log transformed K data ggplot(data = props, aes(log(K))) + geom_histogram() Figure 3.3: Histogram of total K concentrations (log transformed) 3.2.3 XRPD data Given there are 935 diffractograms within the xrpd data, it is not possible to visually inspect all data at once. To start with, it is probably worth visualising the diffractograms from one Sentinel site at a time. plot(as_multi_xy(xrpd[props$SSN[props$Sentinel_site == &quot;Didy&quot;]]), wavelength = &quot;Cu&quot;, normalise = TRUE) Figure 3.4: Diffractograms associated with the Didy site. Visualising the data in this way shows how the strongest peak in each diffractogram at the Didy Sentinel Site occurs at approximately 26 \\(^\\circ\\) 2. Further inspection of this peak shows how there are minor adjustments in alignment that will need to be applied to the data: plot(as_multi_xy(xrpd[props$Sentinel_site == &quot;Didy&quot;]), wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26,27)) Figure 3.5: The major quartz peak of the diffractograms associated with the Didy site, highlighting small 2theta misalignments. This strong peak is associated with quartz, which is omnipresent in soil datasets like this and is a strong diffractor of X-rays. Together this results in quartz peaks being the dominant signal in most soil diffractograms, which is a feature that can be particularly useful for peak alignment when pre-treating the data. 3.3 Data pre-treatment Prior to applying Cubist to the XRPD data, it is important to apply corrections for sample-independent variation such as small 2 misalignments and/or fluctuations in count intensities. 3.3.1 Alignment The small 2 misalignments identified above can be corrected for using the align_xy() function in powdR. Quartz is omnipresent within the dataset and therefore the samples can be aligned to a pure quartz pattern. A pure quartz pattern can be created from the rockjock library, and then used for sample alignment within a restricted 2 range. #Extract a quartz pattern from rockjock quartz &lt;- as_xy(data.frame(rockjock$tth, rockjock$xrd$QUARTZ)) plot(quartz, wavelength = &quot;Cu&quot;) Figure 3.6: A pure quartz pattern extracted from the rockjock reference library. #Align the xrpd data to this quartz pattern #using a restricted 2theta range of 10 to 60 xrpd_pt &lt;- align_xy(xrpd, std = quartz, xmin = 10, xmax = 60, xshift = 0.2) plot(as_multi_xy(xrpd_pt[props$Sentinel_site == &quot;Didy&quot;]), wavelength = &quot;Cu&quot;, normalise = TRUE, xlim = c(26,27)) Figure 3.7: Diffractograms from the Didy site aligned to the quartz pattern extracted from the rockjock reference library. Alignment of the data in this way is important because even seemingly small misalignments between peaks can hinder the comparison of XRPD data by multivariate methods, and hence reduce the effectiveness of the analysis (Butler et al. 2019). 3.3.2 Subsetting In Figure 3.4 it can be observed that below ~4 \\(^\\circ\\) 2 there is a tall tail in count intensities. This tail can be removed by subsetting the data using the code described above. xrpd_pt &lt;- lapply(xrpd_pt, subset, tth &gt;= 5 &amp; tth &lt;= 75) plot(as_multi_xy(xrpd_pt[props$Sentinel_site == &quot;Didy&quot;]), wavelength = &quot;Cu&quot;) Figure 3.8: Aligned diffractograms subset to remove data below 5 degrees 2theta. 3.3.3 Mean centering In addition to alignment and subsetting, it can be useful to adjust the data for fluctuating count intensities that can be associated with factors such as the natural deterioration of the X-ray source over time. Such adjustment can be achieved by mean centering, which subtracts the mean from the count intensities of each sample: #Create a mean centering function mean_center &lt;- function(x) { x[[2]] &lt;- x[[2]] - mean(x[[2]]) return(x) } #apply the function to all patterns xrpd_pt &lt;- lapply(xrpd_pt, mean_center) #Inspect the data from Didy plot(as_multi_xy(xrpd_pt[props$Sentinel_site == &quot;Didy&quot;]), wavelength = &quot;Cu&quot;) Figure 3.9: Aligned, subset and mean centred diffractograms. Now we are left with the dataset xrpd which consists of 935 diffractograms that have each been aligned, subset and mean centred. At this point we are ready to apply the Cubist algorithm to the data. 3.4 Creation of training and test datasets Cubist is a supervised machine learning algorithm and therefore requires training using a dataset that accounts for much of the variation that may be observed in the dataset that Cubist predicts a given soil property from. Here, 75 % of the data will be used as a training set for Cubist to develop appropriate decisions and regression models from (hereafter the training dataset. The remaining 25 % of the data will be used to test the accuracy of the derived models on new data (i.e. data that was not used to train the model; hereafter the test dataset). There are a range of different approaches for defining the training and test datasets. Here a purely random approach will be employed using the sample() function: #Set the seed for random number generation #so that results are reproducible. set.seed(10) #Randomly select 75% of the samples selection &lt;- sample(1:nrow(props), size = round(nrow(props)*0.75), replace = FALSE) 3.5 Using Cubist Here Cubist will be applied to the XRPD data in order to predict and interpret total K concentrations. Underpinning this approach is the principle that a soil diffractogram represents a reproducible signature of that soils mineral composition, and the mineral composition is a key controller of total K concentrations. The code can be readily adapted to any of the other properties within the data, or to your own soil XRPD data and associated properties. To run Cubist the XRPD data need to be supplied in dataframe format, with each row of the dataframe representing a sample. The XRPD data can easily be converted to a dataframe using the multi_xy_to_df function outlined above: #double check that the order of xrpd and props #data match identical(names(xrpd_pt), props$SSN) ## [1] TRUE #create a data frame xrpd_df &lt;- multi_xy_to_df(as_multi_xy(xrpd_pt), tth = TRUE) #transpose the data so that each sample is a row cubist_xrpd &lt;- data.frame(t(xrpd_df[-1])) There are a couple of parameters that can be adjusted when training Cubist models: committees and neighbours (see Butler, ORourke, and Hillier (2018)). Various routines exist for tuning these parameters in order to produce the most accurate models. For further reading on this tuning process, see the caret (Kuhn 2021) and Cubist (Kuhn and Quinlan 2021) package documentation . For simplicity, the adjustable Cubist parameters used in this example will be set to committees = 10 when training the models, and neighbours = 9 when using the derived models to predict total K concentrations from new data. The Cubist models can be trained using the training dataset using: library(Cubist) #Create a Cubist model for K cubist_K &lt;- cubist(x = cubist_xrpd[selection,], y = props$K[selection], committees = 10) following which, the derived models can be used to predict the total K concentrations from XRPD data in the test dataset: #Predict K predict_K &lt;- predict(cubist_K, cubist_xrpd[-selection,], neighbours = 9) #Plot measured K vs predicted K plot(x = log(props$K[-selection]), log(predict_K), xlab = &quot;log(Measured K), ppm&quot;, ylab = &quot;log(Predicted K), ppm&quot;) abline(0,1) #Add a 1:1 line #R2 of measured K vs predicted K cor(log(props$K[-selection]), log(predict_K))^2 ## [1] 0.8540419 The Cubist model for K prediction therefore results in a relatively accurate prediction of K, with an \\(R^2\\) of ~0.85. This indicates that Cubist is able to extract appropriate variables from the XRPD data and use them to predict chemical soil properties. 3.6 Inspection of Cubist models The variables that Cubist selects can be plotted in order to decipher the mineral contributions to a given soil property: #Extract the usage data from the Cubist model K_usage &lt;- cubist_K$usage #Make sure the variable names are numeric so that they can be ordered K_usage$Variable &lt;- as.numeric(substr(K_usage$Variable, 2, nchar(K_usage$Variable))) #Order the K_usage data by Variable now it is numeric K_usage &lt;- K_usage[order(K_usage$Variable), ] #Add the 2theta axis K_usage$tth &lt;- xrpd_df$tth #Add a mean diffracotgram to the data K_usage$counts &lt;- rowMeans(xrpd_df[-1]) #Create a function that normalises a vector data to a minimum of 0 #and maximum of 1. range01 &lt;- function(x){(x-min(x))/(max(x)-min(x))} #Create the plot ggplot(data = K_usage) + geom_linerange(aes(x = tth, ymax = Model/100, ymin = 0), colour = &quot;grey81&quot;, size = 1) + geom_linerange(aes(x = tth, ymax = Conditions/100, ymin = 0), colour = &quot;grey19&quot;, size = 1) + geom_line(aes(x = tth, y = range01(counts)), colour = &quot;red&quot;, size = 0.5) + ylab(&quot;Scaled counts and fraction of variable use\\n&quot;) + xlab(&quot;2theta&quot;) + theme_bw() Figure 3.10: Features selected by Cubist for the prediction of K. Grey sticks denote the fraction of variable use in the regression models and black sticks denote the fraction of variable use in decision. Red line is the mean diffractogram for the dataset. Figure 3.10 shows how the most important variables for prediction of K concentrations are found between 25 and 30 \\(^\\circ\\) 2. To further aid with interpretation of such regions, these plots can be combined with data from full pattern summation so that the variables selected by Cubist can be attributed to specific minerals. For example: f1 &lt;- fps(lib = rockjock, smpl = xrpd$icr014764, std = &quot;QUARTZ&quot;, refs = c(&quot;K-feldspar&quot;, &quot;Quartz&quot;, &quot;Mica (Tri)&quot;, &quot;Organic matter&quot;, &quot;Halloysite&quot;, &quot;Kaolinite&quot;, &quot;Rutile&quot;, &quot;Background&quot;), align = 0.2) ## ## -Harmonising library to the same 2theta resolution as the sample ## -Aligning sample to the internal standard ## -Interpolating library to same 2theta scale as aligned sample ## -Optimising... ## -Removing negative coefficients and reoptimising... ## -Removing negative coefficients and reoptimising... ## -Removing negative coefficients and reoptimising... ## -Computing phase concentrations ## -Internal standard concentration unknown. Assuming phases sum to 100 % ## ***Full pattern summation complete*** yields a reasonable fit of the data, as can be inspected using plot(f1, wavelength = \"Cu\", interactive = TRUE). To help identify what minerals the variables between 25 and 30 \\(^\\circ2\\) 2 are associated with, the results in f1 can be combined with the results in K_usage: #Create a plot of the full pattern summation results p1 &lt;- plot(f1, wavelength = &quot;Cu&quot;, group = TRUE) #Define the layers for the sticks that will have to be placed #BENEATH the data in p1 p2 &lt;- geom_linerange(data = K_usage, aes(x = tth, ymax = (Model/100)*max(f1$measured), ymin = 0), colour = &quot;grey81&quot;, size = 1) p3 &lt;- geom_linerange(data = K_usage, aes(x = tth, ymax = (Conditions/100)*max(f1$measured), ymin = 0), colour = &quot;grey19&quot;, size = 1) #Order the layers so that p2 and p3 are beneath p1 p1$layers &lt;- c(p2, p3, p1$layers) #Limit the x-axis to between 25 and 30 degrees so that the #dominant features can be easily examned p1 &lt;- p1 + scale_x_continuous(limits = c(25, 30)) p1 Figure 3.11: Combining the results from full pattern summation with the features selected by Cubist for prediction of K concentrations. To make the data in Figure 3.11 interactive, its possible to use the ggplotly() function of the plotly package via: library(plotly) ggplotly(p1) From these plots (in particular the interactive version), it is possible to infer that the variables selected by Cubist in this region are specifically related to K-feldspar contributions to the diffraction data. K-feldspar minerals represent the major K-reserves in most soils and this selection by Cubist is therefore completely appropriate. Further mineral sources of other nutrients and micronutrients within this or other datasets can be inferred in a similar manner. References "],["cluster-analysis.html", "Chapter 4 Cluster analysis of soil XRPD data 4.1 Loading packages and data 4.2 Principal component analysis 4.3 Fuzzy clustering 4.4 Exploring results", " Chapter 4 Cluster analysis of soil XRPD data This chapter will demonstrate the use of cluster analysis to identify mineral-nutrient relationships in African soils. The examples provided for the cluster analysis use the data presented in Butler et al. (2020) that is hosted here on Mendeley Data. To run the examples in this chapter on your own machine, you will need to download the soil property data in .csv format and the XRPD data in a zipped folder of xy files. Please simply save these files to your own directory, and unzip the zipped folder containing the .xy files. Skip this step if you have already downloaded these files for the examples in Chapter 3, Download soil property csv Download zipped XRPD data 4.1 Loading packages and data This chapter will use a number of packages that should already be installed on your machine, but will also use the reshape2 and e1071 packages that may need to be installed if you have not used them before: #install packages that haven&#39;t been used in the course before install.packages(c(&quot;reshape2&quot;, &quot;e1071&quot;)) #load the relevant packages library(reshape2) library(e1071) library(leaflet) library(powdR) library(ggplot2) library(plotly) library(gridExtra) library(plyr) Once you have loaded the packages and downloaded the data required for this chapter (note that it is the same data as that used in Chapter 3), the data can be loaded into R by modifying the paths in the following code: #Load the soil property data props &lt;- read.csv(file = &quot;path/to/your/file/clusters_and_properties.csv&quot;) #Get the full file paths of the XRPD data xrpd_paths &lt;- dir(&quot;path/to/xrd&quot;, full.names = TRUE) #Load the XRPD data xrpd &lt;- read_xy(files = xrpd_paths) #Make sure the data are interpolated onto the same 2theta scale #as there are small differences within the dataset xrpd &lt;- interpolate(xrpd, new_tth = xrpd$icr030336$tth) The resulting loaded data matches that loaded and explored in Chapter 3, with the props data containing a range of geochemical soil properties and the xrpd data containing an XY diffractogram of each sample. 4.2 Principal component analysis The cluster analysis in this Chapter is applied to principal components of soil XRPD data derived using Principal Component Analysis [PCA; Jolliffe (1986)]. Prior to applying cluster analysis to the XRPD data via this approach, it is important to apply corrections for sample-independent variation such as small 2 misalignments and/or fluctuations in count intensities. For this example, the pre-treatment routine will be based on that defined in Butler et al. (2020), and will involve alignment, subsetting, square root transformation and mean centering. Together these correct for common experimental aberrations so that the variation in the observed data is almost entirely sample-dependent. The pre-treatment steps used here also match those described in Section 3.3 except for the additional step of square root transforming the data, which acts to reduce the relative intensity of quartz peaks that can often dominate the overall variation in diffraction data. Alignment of the data can be carried out using the align_xy() function, which aligns each sample within the dataset to a pure reference pattern, which in this case will be quartz that is omnipresent within the soil dataset: #load the afsis reference library data(afsis) #Extract a quartz pattern from it quartz &lt;- data.frame(afsis$tth, afsis$xrd$QUARTZ_1_AFSIS) #Align the xrpd data to this quartz pattern #using a restricted 2theta range of 10 to 60 xrpd_aligned &lt;- align_xy(xrpd, std = quartz, xmin = 10, xmax = 60, xshift = 0.2) Aligned data can then be subset to 2 &gt;= 6 so that the high background at low angles (Figure 3.4) in the data can be removed. xrpd_aligned_sub &lt;- lapply(xrpd_aligned, subset, tth &gt;= 6) Following alignment, the remaining data pre-treatment steps (square root transform and mean centering) and the PCA can all be carried out in a single step using the xrpd_pca() function from powdR: pca &lt;- xrpd_pca(xrpd_aligned_sub, mean_center = TRUE, root_transform = 2, components = 5) #View the variance explained by the first 5 PCs pca$eig[1:5,] ## eigenvalue variance.percent cumulative.variance.percent ## Dim.1 32304.1020 81.451846 81.45185 ## Dim.2 2073.3848 5.227851 86.67970 ## Dim.3 1054.2328 2.658152 89.33785 ## Dim.4 731.3746 1.844094 91.18194 ## Dim.5 611.6932 1.542329 92.72427 From which it can be seen that the first 5 principal components (PCs) of the data account for 93 % of variation in the XRPD data. For simplicity this example will use the first 5 PCs hereafter, which can be plotted against one-another using the following code: #Define the x-axis components x &lt;- c(1, 1, 1, 1, 2, 2, 2, 3, 3, 4) #Define the y-axis components y &lt;- c(2, 3, 4, 5, 3, 4, 5, 4, 5, 5) #Create and empty list p &lt;- list() #Populate each item in the list using the dimension defined #in x and y for (i in 1:length(x)) { p[[i]] &lt;- ggplot(data = pca$coords) + geom_point(aes_string(x = paste0(&quot;Dim.&quot;, x[i]), y = paste0(&quot;Dim.&quot;, y[i])), shape = 21, size = 3) } grid.arrange(grobs = p, ncol = 2) Figure 4.1: The first 5 PCs plotted against one-another 4.2.1 Interpreting pricipal components Whilst were able to derive that the first 5 PCs explain 93 % of variation in the XRPD data and plot the resulting variables against one-another, we are still not in a position to interpret what the scores actually mean. For example, how do increased/decreased values in Dim.1 reflect mineralogical differences in the soil samples? This interpretation can be achieved by examining the loadings of each PC dimension, for example the loading of Dim.1 can be visualised via: ggplot(data = pca$loadings) + geom_line(aes(x = tth, y = Dim.1)) + geom_hline(yintercept = 0) Figure 4.2: The loading of Dim.1. These loadings represent the weights of each variable that are used when calculating the PCs. In this case, increased values of Dim.1 would result from increased intensity in the regions of the positive peaks of the loading, whereas decreased values of Dim.1 would result from increased intensity in regions of broad but negative peaks. In order to ascertain what these positive and negative features represent, it is possible to apply the full pattern summation principles outlined in Chapter 2 to the loadings. Whilst full pattern summation for quantitative analysis deals with scaling factors that should only be positive, the loadings of each PC can be modeled in a similar manner by allowing the scaling coefficients to be either positive or negative. Such analysis can be achieved using the fps_lm() function of powdR. This function uses linear regression to compute the scaling factor and allows you to set a p-value that can help omit unnecessary patterns from the fit. Whilst the full pattern summation outlined in Chapter 2 results in phase quantification, fps_lm() is only intended to help with the identification of reference library patterns contributing to a given pattern and therefore does not require or use Reference Intensity Ratios. Below fps_lm() is used to model the loading of Dim.1: #Load the rockjock library data(rockjock) #Merge the rockjock and afsis libraries rockjock_afsis &lt;- merge(rockjock, afsis) #All patterns in the library need to be square root transformed #because this transformation was applied to the soil data #during the use of xrpd_pca(). In order to avoid errors with the square #root transforms, any reference pattern with negative counts #must be removed from the library remove_index &lt;- which(unlist(lapply(rockjock$xrd, min)) &lt; 0) rockjock_afsis &lt;- subset(rockjock_afsis, refs = names(rockjock_afsis$xrd)[remove_index], mode = &quot;remove&quot;) #Square root transform the counts rockjock_afsis_sqrt &lt;- rockjock_afsis rockjock_afsis_sqrt$xrd &lt;- sqrt(rockjock_afsis_sqrt$xrd) #Produce a fit using a subset of common soil minerals dim1_fit &lt;- fps_lm(rockjock_afsis_sqrt, smpl = data.frame(pca$loadings$tth, pca$loadings$Dim.1), refs = c(&quot;Quartz&quot;, &quot;Organic matter&quot;, &quot;Plagioclase&quot;, &quot;K-feldspar&quot;, &quot;Goethite&quot;, &quot;Illite&quot;, &quot;Mica (Di)&quot;, &quot;Kaolinite&quot;, &quot;Halloysite&quot;, &quot;Dickite&quot;, &quot;Smectite (Di)&quot;, &quot;Smectite (ML)&quot;, &quot;Goethite&quot;, &quot;Gibbsite&quot;, &quot;Amphibole&quot;, &quot;Calcite&quot;, &quot;Ferrihydrite&quot;), std = &quot;QUARTZ_1_AFSIS&quot;, align = 0, #No alignment needed p = 0.01) ## ## -Harmonising sample to the same 2theta resolution as the library ## -Applying linear regression ## -Removing coefficients with p-value greater than 0.01 ## -Removing coefficients with p-value greater than 0.01 ## -Removing coefficients with p-value greater than 0.01 ## ***Full pattern summation complete*** plot(dim1_fit, wavelength = &quot;Cu&quot;, group = TRUE) Figure 4.3: Full pattern summation applied to the loading of Dim.1. dim1_fit$phases_grouped[order(dim1_fit$phases_grouped$coefficient),] ## phase_name coefficient ## 11 Quartz -3.081022e-03 ## 8 K-feldspar -3.169293e-05 ## 12 Smectite (Di) -2.213481e-05 ## 9 Organic matter 1.171259e-05 ## 7 Illite 1.672584e-05 ## 4 Ferrihydrite 1.692329e-05 ## 1 Amphibole 2.371968e-05 ## 5 Gibbsite 2.664863e-05 ## 6 Goethite 3.529204e-05 ## 3 Dickite 3.673291e-05 ## 2 Calcite 6.545188e-05 ## 10 Plagioclase 1.048826e-04 ## 13 Smectite (ML) 2.813015e-04 By interpreting the plot (particularly using interactive = TRUE) and the coefficients it can be seen that more negative Dim.1 scores are promoted by increased intensity of quartz peaks, whereas more positive Dim.1 scores are promoted by increased intensity of Smectite peaks. Dim.1 can therefore be interpreted to broadly represent the acid-basic gradient of soil parent materials. Applying the same analysis to the loading of Dim.2 yields a very different interpretation: dim2_fit &lt;- fps_lm(rockjock_afsis_sqrt, smpl = data.frame(pca$loadings$tth, pca$loadings$Dim.2), refs = c(&quot;Quartz&quot;, &quot;Organic matter&quot;, &quot;Plagioclase&quot;, &quot;K-feldspar&quot;, &quot;Goethite&quot;, &quot;Illite&quot;, &quot;Mica (Di)&quot;, &quot;Kaolinite&quot;, &quot;Halloysite&quot;, &quot;Dickite&quot;, &quot;Smectite (Di)&quot;, &quot;Smectite (ML)&quot;, &quot;Goethite&quot;, &quot;Gibbsite&quot;, &quot;Amphibole&quot;, &quot;Calcite&quot;, &quot;Ferrihydrite&quot;), std = &quot;QUARTZ_1_AFSIS&quot;, align = 0, #No alignment needed p = 0.01) ## ## -Harmonising sample to the same 2theta resolution as the library ## -Applying linear regression ## -Removing coefficients with p-value greater than 0.01 ## -Removing coefficients with p-value greater than 0.01 ## ***Full pattern summation complete*** plot(dim2_fit, wavelength = &quot;Cu&quot;, group = TRUE) Figure 4.4: Full pattern summation applied to the loading of Dim.2. dim2_fit$phases_grouped[order(dim2_fit$phases_grouped$coefficient),] ## phase_name coefficient ## 12 Plagioclase -1.209673e-03 ## 9 K-feldspar -9.533729e-04 ## 2 Calcite -4.138665e-04 ## 8 Illite -3.952620e-04 ## 15 Smectite (ML) -3.182366e-04 ## 7 Halloysite -1.450224e-04 ## 11 Organic matter -7.906963e-05 ## 4 Ferrihydrite -5.087144e-05 ## 1 Amphibole -3.251187e-05 ## 13 Quartz 1.990181e-05 ## 6 Goethite 4.349864e-05 ## 14 Smectite (Di) 1.256807e-04 ## 3 Dickite 1.287611e-04 ## 5 Gibbsite 1.935992e-04 ## 10 Kaolinite 9.066849e-04 with more negative scores associated with increased plagioclase and K-feldspar peak intensities, and more positive scores associated with increased kaolinite and gibbsite peak intensities. Dim.2 can therefore be interpreted to represent an index of chemical alteration, with higher values representing a greater degree of alteration (i.e. the weathering of feldspars to kaolinite and gibbsite and associated loss of base cations). The same analysis can be applied for the interpretation of subsequent PCA dimensions, but can become increasingly challenging when the loading vector becomes comprised of minor or diffuse features of the XRPD data. 4.3 Fuzzy clustering Cluster analysis will be now applied to the 5 PCs plotted in Figure 4.1 using fuzzy-c-means clustering algorithm implemented in the e1071 package (Meyer et al. 2021). When applying cluster analysis, the selection of the most appropriate number of clusters can prove to be subjective and, in some cases, difficult. There are a number of approaches that can be used to objectively define the most appropriate number of clusters (Rossel et al. 2016; Butler et al. 2020), but for simplicity the number of clusters used in this example will be manually defined as 9: #Apply the fuzzy-c-means algorithm to the PCs fcm &lt;- cmeans(pca$coords[-1], center = 9) #check the data are in the same order identical(names(fcm$cluster), pca$coords$sample_id) ## [1] TRUE clusters &lt;- data.frame(&quot;SSN&quot; = names(fcm$cluster), &quot;CLUSTER&quot; = paste0(&quot;C&quot;, unname(fcm$cluster)), pca$coords[-1]) #Reorder the clusters based on Dim.1 #Lowest mean Dim.1 will be Cluster 1 #Highest mean Dim.1 will be Cluster 9 dim1_mean &lt;- aggregate(Dim.1 ~ CLUSTER, data = clusters, FUN = mean) #Order so that the Dim.1 mean is ascending dim1_mean &lt;- dim1_mean[order(dim1_mean$Dim.1),] dim1_mean$NEW_CLUSTER &lt;- paste0(&quot;C&quot;, 1:nrow(dim1_mean)) #Create a named vector that will be used to revalue cluster names #Values of the vector are the new values, and old values are the names rv &lt;- setNames(dim1_mean$NEW_CLUSTER, # the vector values dim1_mean$CLUSTER) #the vector names #use the revalue function to create a new cluster column clusters$NEW_CLUSTER &lt;- revalue(clusters$CLUSTER, rv) #Create an empty list p &lt;- list() #Populate each item in the list using the dimension already #defined in x and y above for (i in 1:length(x)) { p[[i]] &lt;- ggplot(data = clusters) + geom_point(aes_string(x = paste0(&quot;Dim.&quot;, x[i]), y = paste0(&quot;Dim.&quot;, y[i]), fill = &quot;NEW_CLUSTER&quot;), shape = 21, size = 3, alpha = 0.5) + guides(fill = guide_legend(title=&quot;Cluster&quot;)) } grid.arrange(grobs = p, ncol = 2) Figure 4.5: Pre-treated XRPD data clustered into 9 groups. 4.3.1 Cluster membership Use of the fuzzy-c-means clustering algorithm results in every sample having a membership coefficient for each cluster. These membership coefficients range from 0 to 1, with 1 being the highest degree of membership. Below these membership coefficients will be plotted using the first 2 PCs in order to help visualise the fuzzy nature of the clustering: #Extract the membership coefficients members &lt;- data.frame(fcm$membership, check.names = FALSE) #Add C to all the names to match that used above. names(members) &lt;- paste0(&quot;C&quot;, names(members)) #revalue the names based on the new clustering order names(members) &lt;- revalue(names(members), rv) #Add membership to the name names(members) &lt;- paste0(&quot;Membership_&quot;, names(members)) #Join clusters and members members &lt;- data.frame(clusters, members) #Create and empty list for the plots p &lt;- list() #Populate each item in the list using the dimension defined #in x and y for (i in 1:9) { p[[i]] &lt;- ggplot(data = members) + geom_point(aes_string(x = &quot;Dim.1&quot;, y = &quot;Dim.2&quot;, fill = paste0(&quot;Membership_C&quot;, i)), shape = 21, size = 3, alpha = 0.5) + ggtitle(paste(&quot;Cluster&quot;, i)) + theme(legend.position = &quot;None&quot;) + scale_fill_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) } grid.arrange(grobs = p, ncol = 3) Figure 4.6: Membership coefficients for the nine clusters plotted for the first two PCs. Blue symbols have low membership (~0), whilst red symbols have high membership (~1). Together Figures 4.5 and 4.6 illustrate how the soil XRPD data in this data set reflect to soil mineral continuum, and as such can be challenging to cluster into a discrete number of groups. In particular the membership coefficients in Figure 4.6 help highlight how soils can exist on the boundary of two or more clusters and therefore have similar membership coefficients to numerous clusters. This property is characteristic of most large soil data sets, and can make it challenging to define very distinct clusters. However, the membership coefficients data can be used so that only samples with the highest coefficients are retained, resulting in more distinct mineralogical groups that do no overlap. 4.3.2 Subsetting Clusters Here, more mineralogically distinct clusters will be created by only retaining samples within each cluster that have a membership coefficient exceeding the 75th percentile: #Create a blank name to populate with the unique SSNs member_ssn &lt;- list() #A loop to omit samples from each cluster with low membership coefficient for (i in 1:9) { memberships &lt;- members[which(members$NEW_CLUSTER == paste0(&quot;C&quot;, i)), c(&quot;SSN&quot;, paste0(&quot;Membership_C&quot;, i))] #Extract the samples with top 25 % of membership coefficient for each cluster memberships_75 &lt;- which(memberships[[2]] &gt; quantile(memberships[[2]], probs = 0.75)) member_ssn[[i]] &lt;- memberships$SSN[memberships_75] names(member_ssn)[i] &lt;- paste0(&quot;C&quot;, i) } #Unlist the indexes member_ssn &lt;- unname(unlist(member_ssn)) members_sub &lt;- members[which(members$SSN %in% member_ssn),] #Plot the results #Create and empty list p &lt;- list() #Populate each item in the list using the dimension defined #in x and y for (i in 1:length(x)) { p[[i]] &lt;- ggplot(data = members_sub) + geom_point(aes_string(x = paste0(&quot;Dim.&quot;, x[i]), y = paste0(&quot;Dim.&quot;, y[i]), fill = &quot;NEW_CLUSTER&quot;), shape = 21, size = 3, alpha = 0.5) + guides(fill = guide_legend(title=&quot;Cluster&quot;)) } grid.arrange(grobs = p, ncol = 2) Figure 4.7: The formation of distinct clusters by retaining the samples within each cluster that have membership coefficients greater than the 75% percentile. 4.4 Exploring results Now that a set of mineralogically distinct clusters have been defined from the data, there are number of ways that the data can be explored in order to relate the soil mineral composition to the nutrient concentrations. Firstly, since these data are geo-referenced, the spatial distribution of each cluster can be visualised, for example: clust_sub &lt;- join(members_sub[c(&quot;SSN&quot;, &quot;NEW_CLUSTER&quot;)], props, by = &quot;SSN&quot;) #Plot cluster 9 leaflet(clust_sub[which(clust_sub$NEW_CLUSTER == &quot;C1&quot;), ]) %&gt;% addTiles() %&gt;% addCircleMarkers(~Longitude, ~Latitude) Figure 4.8: Interactive map of the soil samples associated with Cluster 9. returns a map of the locations of all samples within Cluster 9. Even though samples within this cluster are dispersed across sub-Saharan Africa, their XRPD signals (and, hence mineralogies) are very similar, which can readily be plotted with a little manipulation of the data: #Create a blank list to populate cluster_xrpd &lt;- list() for (i in 1:9) { cluster_xrpd[[i]] &lt;- xrpd_aligned[clust_sub$SSN[clust_sub$NEW_CLUSTER == paste0(&quot;C&quot;,i)]] names(cluster_xrpd)[i] &lt;- paste0(&quot;C&quot;, i) } #Plot cluster 9 plot(as_multi_xy(cluster_xrpd$C1), wavelength = &quot;Cu&quot;, normalise = TRUE) Figure 4.9: Clustered pre-treated XRPD from Cluster 9. Given that the soil mineral composition ultimately governs the total concentrations of nutrients and their phyto-availability, the nine mineralogically different clusters defined here should display contrasting geochemical properties. These geochemical properties are present in the props data that has already been combined with the clustering data in clust_sub. Here the relative enrichments and deficiencies of each cluster with respect to total nutrient concentrations will be visualised using barplots (Montero-Serrano et al. 2010; Butler et al. 2020): #Select the variables of interest total_nutrients &lt;- subset(clust_sub, select = c(NEW_CLUSTER, TOC, K, Ca, Mn, Fe, Ni, Cu, Zn)) #Create geometric mean function gmean &lt;- function(x) {exp(mean(log(x)))} #Compute overall geometric means for each nutrient (i.e. column) total_nutrients_gmeans &lt;- apply(total_nutrients[-1], 2, gmean) #Compute the geometric mean for each nutrient by cluster cluster_gmeans &lt;- by(total_nutrients[-1], as.factor(total_nutrients$NEW_CLUSTER), function(x) apply(x, 2, gmean)) #Bind the data by row cluster_gmeans &lt;- do.call(rbind, cluster_gmeans) #Calculate log-ratios by dividing by the geometric mean #of each nutrient bp &lt;- apply(cluster_gmeans,1, function(x) log(x/total_nutrients_gmeans)) #Use melt from the reshape2 package so that the data are #in the right format for ggplot2: bpm &lt;- melt(bp) #Create a barplot using ggplot2 g1 &lt;- ggplot(bpm, aes(fill=Var1, y=value, x=Var2)) + geom_bar(position=&quot;dodge&quot;, stat=&quot;identity&quot;) + theme(legend.title = element_blank()) + xlab(&quot;Cluster&quot;) + ylab(&quot;&quot;) #Make the barplot interactive ggplotly(g1) Figure 4.10: Average total nutrient concentrations of each cluster expressed as deviation in log-ratio scale from the geometric mean. Values below zero represent average concentrations lower than that for the entire dataset, whilst values above zero represent the opposite. The resulting barplot illustrates how the nine clusters defined by the XRPD data are characterised by contrasting geochemical compositions. Clusters 8 and 9 are by far the most deficient in all nutrients, whilst Clusters 1, 2 and 3 are enriched in all nutrients (with the exception of K in Cluster 1). Interestingly, soils in Cluster 6 have the highest concentrations of total K on average, but are generally deficient in other nutrients. The relationships between the geochemical compositions of each cluster and the mineralogy can be interpreted by quantifying the mean diffractogram of each cluster using the full pattern summation functions outlined in Chapter 2: #Create a blank list to be populated xrpd_clusters &lt;- list() #Calculate the mean diffractogram of each cluster for (i in 1:9) { #Extract the SSN for the cluster ssns &lt;- clust_sub$SSN[which(clust_sub$NEW_CLUSTER == paste0(&quot;C&quot;, i))] #Extract the aligned xrpd data and make sure it is a multiXY object xrpd_clusters[[i]] &lt;- as_multi_xy(xrpd_aligned[ssns]) names(xrpd_clusters)[i] &lt;- paste0(&quot;C&quot;, i) #Convert to a data frame xrpd_clusters[[i]] &lt;- multi_xy_to_df(xrpd_clusters[[i]], tth = TRUE) #Calculate mean diffractogram xrpd_clusters[[i]] &lt;- as_xy(data.frame(&quot;tth&quot; = xrpd_clusters[[i]]$tth, &quot;counts&quot; = rowMeans(xrpd_clusters[[i]][-1]))) } #Plot the mean diffractogram of Cluster 9 plot(xrpd_clusters$C1, wavelength = &quot;Cu&quot;) Figure 4.11: The mean diffractogram of Cluster 9. Now that the mean diffractogram of each cluster has been computed. The mineralogy of each diffractogram can be quantified using afps() using therockjock_afsis library created above, yielding an approximate average of the mineral composition of each cluster: #Define the names of the minerals to supply to afps usuals &lt;- c(&quot;Quartz&quot;, &quot;Kaolinite&quot;, &quot;Halloysite&quot;, &quot;Dickite&quot;, &quot;Smectite (Di)&quot;, &quot;Smectite (ML)&quot;, &quot;Illite&quot;, &quot;Mica (Di)&quot;, &quot;Muscovite&quot;, &quot;K-feldspar&quot;, &quot;Plagioclase&quot;, &quot;Goethite&quot;, &quot;Maghemite&quot;, &quot;Ilmenite&quot;, &quot;Hematite&quot;, &quot;Gibbsite&quot;, &quot;Magnetite&quot;, &quot;Anatase&quot;, &quot;Amphibole&quot;, &quot;Pyroxene&quot;, &quot;Calcite&quot;, &quot;Gypsum&quot;, &quot;Organic matter&quot;, &quot;HUMIC_ACID&quot;, &quot;FERRIHYDRITE_HUMBUG_CREEK&quot;, &quot;FERRIHYDRITE&quot;, &quot;BACK_POS&quot;) #Define the amorphous phases amorph &lt;- c(&quot;ORGANIC_MATTER&quot;, &quot;ORGANIC_AFSIS&quot;, &quot;HUMIC_ACID&quot;, &quot;FERRIHYDRITE_HUMBUG_CREEK&quot;, &quot;FERRIHYDRITE&quot;) clusters_quant &lt;- lapply(xrpd_clusters, afps, lib = rockjock_afsis, std = &quot;QUARTZ_1_AFSIS&quot;, refs = usuals, amorphous = amorph, align = 0.2, lod = 0.05, amorphous_lod = 0, force = &quot;BACK_POS&quot;) #Load the regrouping structures for rockjock and afsis data(rockjock_regroup) data(afsis_regroup) #lapply the regrouping structure clusters_quant_rg &lt;- lapply(clusters_quant, regroup, y = rbind(rockjock_regroup[1:2], afsis_regroup[1:2])) #Extract the quantitative data quant_table &lt;- summarise_mineralogy(clusters_quant_rg, type = &quot;grouped&quot;, order = TRUE) #Reduce to the 10 most common phases for a barplot quant_table &lt;- quant_table[2:11] The resulting quantification can then be plotted: #Rename clusters C1 to C9 rownames(quant_table) &lt;- paste0(&quot;C&quot;, rownames(quant_table)) #Use melt from the reshape2 package so that the data are #in the right format for ggplot2: quant_table_m &lt;- melt(as.matrix(quant_table)) #Create a barplot using ggplot2 g2 &lt;- ggplot(quant_table_m, aes(fill=Var2, y=value, x=Var1)) + geom_bar(position=&quot;dodge&quot;, stat=&quot;identity&quot;) + theme(legend.title = element_blank()) + xlab(&quot;Cluster&quot;) + ylab(&quot;&quot;) #Make the barplot interactive ggplotly(g2) Figure 4.12: Mineral compositions of the nine clusters based on the mean diffractogram Together the geochemical (Figure 4.10) and mineralogical (Figure 4.12) barplots can be used to interpret a range of relationships between the soil mineral composition and the nutrient concentrations, for instance: The notable K enrichment in the soils of Cluster 6 most likely results from the relatively high concentrations of K-feldspar minerals in these soils. Soils in Clusters 8 and 9 are deficient in all nutrients due to the dominance of quartz in combination with a near absence of clay minerals and/or Fe/Ti(hydr)oxides Soils in Cluster 2 are particularly enriched in Ca due to the high concentrations of plagioclase, expandable/ML clays and calcite (not plotted but can be observed in the tabulated data) minerals. This example ultimately acts to highlight the utility of Digital methods of analysis applied to soil XRPD data. Whilst this example focuses on total nutrient concentrations, the method can also be applied to the Mehlich-3 extractable element concentrations that are also included within the props data. For further analysis and discussion on the application of cluster analysis to this dataset, along with additional methods of compositional data analysis, see Butler et al. (2020) and the accompanying Supplementary Material. References "],["mars.html", "Chapter 5 From Mars to Mull: Interplanetary comparison of soil XRPD data 5.1 Data 5.2 Data manipulation", " Chapter 5 From Mars to Mull: Interplanetary comparison of soil XRPD data This chapter will use data from the Mars Science Laboratory (MSL) onboard NASAs Curiosity Rover. The MSL XRPD data were obtained from the Geosciences Data Volume Online as ASCII .csv files on the 17th July 2021 and loaded into R (Vaniman 2012) using read.csv(). The mineral compositions of the samples in the MSL dataset are described and discussed in numerous publications (Bish et al. 2013; Grotzinger et al. 2014; Vaniman et al. 2014; Bristow et al. 2015, 2018). The many clay minerals identified and quantified from the XRPD provides compelling evidence that the surface material has been altered by water. Qualitative and quantitative analysis of clay minerals is a notoriously challenging undertaking, often requiring separation of the clay fraction onto oriented slides combined with several ethylene-glycol and heat treatments. The MSL cannot separate the clay fraction from Martian samples and is limited to bulk sample analysis, where clay minerals are analysed in a randomly oriented powder along with all other crystalline and amorphous components within the sample. This has acted to create uncertainty in the analysis of clay minerals from MSL XRPD data (Bish et al. 2013; Grotzinger et al. 2014; Vaniman et al. 2014; Bristow et al. 2018). Identification of Earth based analogues for Martian soil mineralogy therefore represent an opportunity to facilitate more accurate interpretation of the clay mineralogy encoded within MSL XRPD data. Further, understanding the development of mineralogically analogous soils on Earth has potential to aid the development of hypotheses for the environmental properties of aqueous systems on ancient Mars (Marlow, Martins, and Sephton 2008). Here, soil XRPD data from the National Soil Inventory of Scotland (Butler, ORourke, and Hillier 2018) will be compared to the XRPD data from Mars in the aim of identifying potential soil analogues for Martian mineralogy. 5.1 Data Data for this example is stored within a mars2mull R package hosted on GitHub. The package can be installed using the devtools package #Install devtools if it&#39;s not already on your machine install.packages(&quot;devtools&quot;) #Use devtools to install the mars2mull package from GitHub devtools::install_github(&quot;benmbutler/mars2mull&quot;) 5.1.1 Mars Science Laboratory XRPD Data Martian XRPD data within the package have been extracted from NASAs Geosciences Data Volume Online (Vaniman 2012) and renamed according to the various sites that were sampled. The diffractograms of 31 Martian samples are contained within the mars_xrpd data in multiXY format. All diffractograms were collected using Co-K\\(\\alpha\\) radiation, with further details of the data collection and instrumental parameters provided elsewhere (Bish et al. 2013; Grotzinger et al. 2014; Vaniman et al. 2014; Bristow et al. 2015, 2018). Further to the XRPD data, additional information about each of the samples is provided in the mars_id data: #load the mars2mull package library(mars2mull) #load powdR so that the XRPD data can be plotted library(powdR) #load the Martian XRPD data data(mars_xrpd) #plot the 31 Martian diffractograms plot(mars_xrpd, wavelength = &quot;Co&quot;, normalise = TRUE, interactive = TRUE) #load the extra information about the samples interactively data(mars_id) #View the first four columns of the mars_id data mars_id[1:4] ## SITE_NAME PRODUCT_ID SAMPLE_TYPE SOL_START ## 1 Rocknest_4 cma_404470826rda00790050104ch11503p1 Scoop 77 ## 2 Rocknest_5 cma_405889312rda00950050104ch11504p1 Scoop 94 ## 3 Cumberland cmb_434685266rda04190180786ch00113p1 Drill 418 ## 4 John_Klein cmb_439549561rda04740240192ch00111p1 Drill 473 ## 5 Windjana cmb_452848863rda06240311330ch00111p1 Drill 623 ## 6 Confidence_Hills cmb_465487684rda07660421020ch00113p2 Drill 765 ## 7 Mojave2 cmb_476051894rda08850450000ch00113p2 Drill 884 ## 8 Telegraph_Peak cmb_479423416rda09230450450ch00113p2 Drill 923 ## 9 Buckskin cmb_491748904rda10620482542ch00111p1 Drill 1061 ## 10 Big_Sky cmb_497096076rda11220500592ch00113p1 Drill 1121 ## 11 Greenhorn cmb_498699740rda11400500676ch00113p1 Drill 1139 ## 12 Gobabeb_Dune cmb_507241145rda12360521162ch00113p1 Scoop 1225 ## 13 Lubango cmb_515083970rda13250540746ch00113p1 Drill 1323 ## 14 Okoruso cmb_515987369rda13350540938ch00111p1 Drill 1334 ## 15 Oudam cmb_518482923rda13630542280ch00113p1 Drill 1361 ## 16 Marimba2 cmb_524082694rda14260561236ch00113p1 Drill 1425 ## 17 Quela cmb_528182076rda14720580642ch00113p1 Drill 1470 ## 18 Sebina cmb_530590971rda14990582136ch00113p1 Drill 1496 ## 19 Ogunquit_Beach cmb_560285885rda18340660952ch00113p2 Scoop 1831 ## 20 Duluth cmb_581124537rda20690701752ch00111p1 Drill 2068 ## 21 Stoer cmb_587626717rda21420721316ch00111p1 Drill 2141 ## 22 Aberlady cmb_608205076rda23740751386ch00111p1 Drill 2373 ## 23 Kilmarie cmb_609535789rda23890751398ch00111p1 Drill 2388 ## 24 Glen_Etive_1 cmb_618807226rda24920763002ch00113p1 Drill 2492 ## 25 Glen_Etive_2 cmb_623314115rda25430763002ch00111p1 Drill 2543 ## 26 Hutton cmb_634766364rda26720790000ch00111p1 Drill 2672 ## 27 Edinburgh cmb_638579868rda27150790654ch00111p1 Drill 2715 ## 28 Glasgow cmb_642400648rda27580792008ch00111p1 Drill 2758 ## 29 Mary_Anning_1 cmb_649856565rda28420822176ch00111p1 Drill 2842 ## 30 Mary_Anning_3 cmb_653942038rda28880822176ch00111p1 Drill 2887 ## 31 Groken cmb_656073671rda29120822188ch00111p1 &lt;NA&gt; 2912 The locations of the 31 samples can be explored using the SOL_START and SOL_END columns in the mars_id data in combination with NASAs online map for Curiositys location. 5.1.2 Scottish Soil XRPD data The Scottish soil diffractograms relate to 773 samples collected by horizon from 207 sites across Scotland. Samples were collected primarily as part of the second National Soil Inventory of Scotland (NSIS, Butler, ORourke, and Hillier 2018) and are supplemented by additional samples of rare Scottish soils. #Load the scotland_locations data data(scotland_locations) #Show the first 6 rows of the data head(scotland_locations) ## SAMPLE_ID PROFILE_ID PROFILE_LONGITUDE PROFILE_LATITUDE DATASET ## 1 S1018719 S14915 -4.787220 58.53516 Rare ## 2 S1018720 S14915 -4.787220 58.53516 Rare ## 3 S1018728 S14916 -4.774935 58.55841 Rare ## 4 S1018729 S14916 -4.774935 58.55841 Rare ## 5 S1018737 S14917 -4.746896 58.54449 Rare ## 6 S1018738 S14917 -4.746896 58.54449 Rare #load the leaflet package library(leaflet) #Plot the data of &quot;NSIS&quot; and &quot;Rare&quot; samples in different colours leaflet() %&gt;% addTiles() %&gt;% addCircleMarkers(data = scotland_locations[scotland_locations$DATASET == &quot;NSIS&quot;,], ~PROFILE_LONGITUDE, ~PROFILE_LATITUDE, color = &quot;blue&quot;, opacity = 1) %&gt;% addCircleMarkers(data = scotland_locations[scotland_locations$DATASET == &quot;Rare&quot;,], ~PROFILE_LONGITUDE, ~PROFILE_LATITUDE, color = &quot;yellow&quot;, opacity = 1) Figure 5.1: Interactive map of the sampling locations for the Scottish soils. Blue symbols represent samples associated with the NSIS dataset. Yellow symbols represent samples associated with the Rare Soils dataset. The XRPD data were collected using Cu-K radiation (for details see Butler, ORourke, and Hillier 2018) and are included within the mars2mull package in the scotland_xrpd data, which a data frame rather than a multiXY object in order to save on file size when transferring to/from GitHub. #Load the Scottish XRPD data data(scotland_xrpd) #Check the class of the data class(scotland_xrpd) ## [1] &quot;data.frame&quot; 5.2 Data manipulation The aim of this analysis is to compare all Martian diffractograms from the MSL to all Scottish soil diffractograms and hence identify those with the greatest similarity. In this case, similarity will be assessed using the Pearson correlation coefficient. Such comparison requires the data to be on identical 2 axes, which can be achieved by applying the following manipulations need to the data: Transform the 2 scale of the scotland_xrpd data to its Co-K equivalent Calculate the overlapping 2 range of the two datasets Interpolate the data onto a harmonised 2 scale Align each sample during pair-wise comparison References "],["references.html", "References", " References "]]
