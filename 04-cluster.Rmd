# Cluster analysis of soil XRPD data {#cluster-analysis}

This chapter will demonstrate the use of cluster analysis to identify mineral-nutrient relationships in African soils. The examples provided for the cluster analysis use the data presented in @Butler2020 that is hosted [here](https://doi.org/10.17632/r6g94fgx55.1) on Mendeley Data. To run the examples in this chapter on your own machine, you will need to download the soil property data in '.csv' format and the XRPD data in a zipped folder of 'xy' files. Please simply save these files to your own directory, and unzip the zipped folder containing the '.xy' files. **Skip this step if you have already downloaded these files for the examples in Chapter \@ref(machine-learning)**,

```{r, echo=FALSE, cache = TRUE}
if (knitr:::is_html_output())
{
  downloadthis::download_link(
  link = "https://data.mendeley.com/public-files/datasets/r6g94fgx55/files/9b742b95-c071-4e3a-a227-939efa034ac7/file_downloaded",
  button_label = "Download soil property csv",
  button_type = "danger",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
}
```

```{r, echo=FALSE, cache = TRUE}
if (knitr:::is_html_output())
{
  downloadthis::download_link(
  link = "https://data.mendeley.com/public-files/datasets/r6g94fgx55/files/ef33d276-e39c-4b64-b9aa-f2d1d69c51b3/file_downloaded",
  button_label = "Download zipped XRPD data",
  button_type = "danger",
  has_icon = TRUE,
  icon = "fa fa-save",
  self_contained = FALSE
)
}
```

## Loading packages and data
This chapter will use a number of packages that should already be installed on your machine, but will also use the **reshape2** and **e1071**packages that may need to be installed if you have not used them before:

```{r, eval = FALSE}
#install packages that haven't been used in the course before
install.packages(c("reshape2", "e1071"))
```

```{r, message = FALSE, warning = FALSE}
#load the relevant packages
library(reshape2)
library(e1071)
library(leaflet)
library(powdR)
library(ggplot2)
library(plotly)
library(gridExtra)
library(leaflet)
library(plyr)
```

Once you have loaded the packages and downloaded the data required for this chapter (note that it is the same data as that used in Chapter \@ref(machine-learning)), the data can be loaded into R by modifying the paths in the following code:

```{r, eval=FALSE}
#Load the soil property data
props <- read.csv(file = "path/to/your/file/clusters_and_properties.csv")

#Load the XRPD data

#Get the full file paths
xrpd_paths <-  dir("path/to/xrd", full.names = TRUE)

#Load the data
xrpd <- read_xy(files = xrpd_paths)

#Make sure the data are interpolated onto the same 2theta scale
#as there are small differences within the dataset
xrpd <- interpolate(xrpd, new_tth = xrpd$icr030336$tth)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
#This will run in the background because echo = FALSE

#Load the soil property data
props <- read.csv(file = "data/clusters_and_properties.csv")

load("data/afsis_xrpd_df.Rdata")

#Convert it back to a multiXY list
xrpd <- as_multi_xy(xrpd)
```

## Principal component analysis {#clustering-pca}
The cluster analysis in this Chapter is applied to principal components of soil XRPD data derived using Principal Component Analysis (PCA; @Jolliffe1986). Prior to applying cluster analysis to the XRPD data via this approach, it is important to apply corrections for sample-independent variation such as small $2\theta$ misalignments and/or fluctuations in count intensities. For this example, the pre-treatment routine will be based on that defined in @Butler2020, and will involve alignment, subsetting, square root transformation and mean centering. Together these correct for common experimental aberrations so that the variation in the observed data is almost entirely sample-dependent. The pre-treatment steps used here also match those described in Section \@ref(cubist-pretreatment), excepted for the additional step of square root transforming the data, which acts to reduced the relative intensity of quartz peaks that can often dominate the overall variation in diffraction data.

Alignment of the data can be carried out using the `align_xy()` function [outlined above](#cubist-pretreatment), which aligns each sample within the dataset to a pure quartz pattern:

```{r message=FALSE, warning=FALSE, cache = TRUE}
#load the afsis reference library
data(afsis)

#Extract a quartz pattern from rockjock
quartz <- as_xy(data.frame(afsis$tth,
                           afsis$xrd$QUARTZ_1_AFSIS))

#Align the xrpd data to this quartz pattern
#using a restricted 2theta range of 10 to 60
xrpd_aligned <- align_xy(xrpd, std = quartz,
                         xmin = 10, xmax = 60,
                         xshift = 0.2)
```

Aligned data can then be subset to $2\theta$ > 6 so that the [high background at low angles](#cubist-pretreatment) in the data can be removed.

```{r message=FALSE, warning=FALSE, cache = TRUE}
subset_xrpd <- function (x, xmin) {
  
  x <- x[x[[1]] >= xmin, ]
  
  return(x)
  
}

xrpd_aligned_sub <- lapply(xrpd_aligned, subset_xrpd,
                           xmin = 6)
```

Following alignment, the remaining data pre-treatment steps (square root transform and mean centering) and PCA can be carried out in a single step using the `xrpd_pca()` function in `powdR`: 

```{r message=FALSE, warning=FALSE, cache = TRUE}
pca <- xrpd_pca(xrpd_aligned_sub,
                mean_center = TRUE,
                root_transform = 2,
                components = 5)

#View the variance explained by the first 10 PCs
pca$eig[1:10,]
```

From which it can be seen that the first 5 principal components (PCs) of the data account for 93 % of variation in the XRPD data. The resulting cluster analysis will therefore be based upon these 10 components. For simplicity this example will use the first 5 PCs hereafter, which together account for 93 % of total variation.

```{r fig.cap = "The first 5 PCs plotted against one-another", out.width='100%', fig.align='center', fig.asp=2.3, message=FALSE, warning=FALSE, cache = TRUE}
#Define the x-axis components
x <- c(1, 1, 1, 1,
       2, 2, 2,
       3, 3,
       4)

#Define the y-axis components
y <- c(2, 3, 4, 5,
       3, 4, 5,
       4, 5,
       5)

#Create and empty list
p <- list()

#Populate each item in the list using the dimension defined
#in x and y
for (i in 1:length(x)) {
   
   p[[i]] <- ggplot(data = pca$coords) +
             geom_point(aes_string(x = paste0("Dim.", x[i]),
                                   y = paste0("Dim.", y[i])),
                        shape = 21,
                        size = 3)
   
}

grid.arrange(grobs = p,
             ncol = 2)
```

### Interpreting pricipal components
Whilst we're able to derive that the first 10 PCs explain 96 % of variation in the XRPD data and plot the resulting variables against one-another, we are still not in a position to interpret what the scores actually mean. For example, how do increased/decreased values in Dim.1 reflect mineralogical differences in the soil samples. This interpretation can be achieved by examining the loadings of each PC dimension, for example the loading of Dim.1 can be visualised via:


```{r fig.cap = "The loading of Dim.1.", out.width='100%', fig.align='center', fig.asp=0.75, message=FALSE, warning=FALSE, cache = TRUE}
ggplot(data = pca$loadings) +
  geom_line(aes(x = tth, y = Dim.1)) +
  geom_hline(yintercept = 0)
```

These loadings determine the values of each PC. In this case, increased values of Dim.1 would result from increased intensity in the regions of the positive peaks of the loading, whereas decreased values of Dim.1 would result from increased intensity in regions of broad but negative peaks. In order to ascertain what these positive and negative features represent, it is possible to apply the full pattern summation principles outlined in Chapter \@ref(quant) to the data.

Whilst full pattern summation for quantitative analysis deals with scaling factors that should only be positive, the loadings of each PC can be modeled in a similar manner by allowing the scaling coefficients to be *either positive or negative*. Such analysis can be achieved using the `fps_lm()` function of `powdR`. This function uses linear regression and allows you to set a p-value that can help omit unnecessary patterns from the fit. Whilst the full pattern summation outlined in Chapter \@ref(quant) results in phase quantification, `fps_lm()` is only intended to help with the identification of reference library patterns contributing to a given pattern:

```{r, fig.cap = "Full pattern summation applied to the loading of Dim.1.", out.width='100%', fig.align='center', fig.asp=0.75, cache = TRUE}
#Load the rockjock library
data(rockjock)

#Merge the rockjock and afsis libraries
rockjock_afsis <- merge(rockjock, afsis)

#All patterns in the library need to be square root transformed
#because this transformation was already applied to the soil data.
#In order to avoid errors with the square root transforms,any 
#reference pattern with negative counts must be removed
remove_index <- which(unlist(lapply(rockjock$xrd, min)) < 0)

rockjock_afsis <- subset(rockjock_afsis,
                         refs = names(rockjock_afsis$xrd)[remove_index],
                         mode = "remove")

#Square root transform the counts
rockjock_afsis_sqrt <- rockjock_afsis
rockjock_afsis_sqrt$xrd <- data.frame(lapply(rockjock_afsis_sqrt$xrd, sqrt))

dim1_fit <- fps_lm(rockjock_afsis_sqrt,
                   smpl = data.frame(pca$loadings$tth,
                                     pca$loadings$Dim.1),
                   refs = c("Quartz",
                            "Organic matter",
                            "Plagioclase",
                            "K-feldspar",
                            "Goethite",
                            "Illite",
                            "Mica (Di)",
                            "Kaolinite",
                            "Halloysite",
                            "Dickite",
                            "Smectite (Di)",
                            "Smectite (ML)",
                            "Goethite",
                            "Gibbsite",
                            "Amphibole",
                            "Calcite",
                            "Ferrihydrite"),
                     std = "QUARTZ_1_AFSIS",
                     align = 0, #No alignment needed
                     p = 0.01)

plot(dim1_fit, wavelength = "Cu", group = TRUE)

dim1_fit$phases_grouped[order(dim1_fit$phases_grouped$coefficient),]
```

By interpreting the plot (particularly using `interactive = TRUE`) and the coefficients it can be seen that more positive Dim.1 scores are promoted by increased intensity of quartz peaks, whereas more negative Dim.1 scores are promoted by increased intensity of Smectite (ML) peaks (mixed-layer smectite). Dim.1 can therefore be interpreted to represent the acid-basic gradient of soil parent materials. Applying the same analysis to the loading of Dim.2 yields a very different interpretation:

```{r, fig.cap = "Full pattern summation applied to the loading of Dim.2.", out.width='100%', fig.align='center', fig.asp=0.75, cache = TRUE}
dim2_fit <- fps_lm(rockjock_afsis_sqrt,
                   smpl = data.frame(pca$loadings$tth,
                                     pca$loadings$Dim.2),
                   refs = c("Quartz",
                            "Organic matter",
                            "Plagioclase",
                            "K-feldspar",
                            "Goethite",
                            "Illite",
                            "Mica (Di)",
                            "Kaolinite",
                            "Halloysite",
                            "Dickite",
                            "Smectite (Di)",
                            "Smectite (ML)",
                            "Goethite",
                            "Gibbsite",
                            "Amphibole",
                            "Calcite",
                            "Ferrihydrite"),
                     std = "QUARTZ_1_AFSIS",
                     align = 0, #No alignment needed
                     p = 0.01)

plot(dim2_fit, wavelength = "Cu", group = TRUE)

dim2_fit$phases_grouped[order(dim2_fit$phases_grouped$coefficient),]
```

with more positive scores associated with increased plagioclase and K-feldspar peak intensities, and more negative scores associated with increased kaolinite and gibbsite peak intensities. Dim.2 can therefore be interpreted to represent an index of chemical alteration, with higher values representing a greater degree of alteration (i.e. the weathering of feldspars to kaolinite and gibbsite and associated loss of base cations). The same type of analysis can be applied for the interpretation of subsequent PCA dimensions, but can become increasingly challenging when the loading vector becomes comprised of minor or diffuse features of the XRPD data.

## Fuzzy clustering
Now that the XRPD data have been reduced to a discrete set of variables using PCA, cluster analysis will be applied. Here the fuzzy-c-means clustering algorithm implemented in the `e1071`  package [@e1071] will be used, which will be applied to the first 10 PCs.

When applying cluster analysis, the selection of the most appropriate number of clusters can prove to be subjective and, in some cases difficult. There are a number of approaches that can be used to objectively define the most appropriate number of clusters [@Rossel2016; @Butler2020]. Here, for simplicity the number of clusters will be manually set to 9.

```{r cluster-fig, fig.cap = "Pre-treated XRPD data clustered into 9 groups.", out.width='100%', fig.align='center', fig.asp=2, cache = TRUE, message = FALSE, warning = FALSE}
#Apply the fuzzy-c-means algorithm to the PCs
fcm <- cmeans(pca$coords[-1],
              center = 9)

#check the data are in the same order
identical(names(fcm$cluster), pca$coords$sample_id)

clusters <- data.frame("SSN" = names(fcm$cluster),
                       "CLUSTER" = unname(fcm$cluster),
                       pca$coords[-1])

#Reorder the clusters based on Dim.1
#Lowest mean Dim.1 will be Cluster 1
#Highest mean Dim.1 will be Cluster 9
dim1_mean <- aggregate(Dim.1 ~ CLUSTER,
                       data = clusters,
                       FUN = mean)

#Order so that the Dim.1 mean is ascending
dim1_mean <- dim1_mean[order(dim1_mean$Dim.1),]
dim1_mean$NEW_CLUSTER <- 1:nrow(dim1_mean)

#Create a column that will be populated with the new
#Cluster classification
clusters$NEW_CLUSTER <- NA

#populate new cluster column
for (i in 1:nrow(dim1_mean)) {
  
  index <- which(clusters$CLUSTER == dim1_mean$CLUSTER[i])
  
  clusters$NEW_CLUSTER[index] <- dim1_mean$NEW_CLUSTER[i]
  
}

#Turn new cluster into a factor
clusters$NEW_CLUSTER <- as.factor(clusters$NEW_CLUSTER)


#Create and empty list
p <- list()

#Populate each item in the list using the dimension defined
#in x and y
for (i in 1:length(x)) {
   
   p[[i]] <- ggplot(data = clusters) +
             geom_point(aes_string(x = paste0("Dim.", x[i]),
                                   y = paste0("Dim.", y[i]),
                                   fill = "NEW_CLUSTER"),
                        shape = 21,
                        size = 3,
                        alpha = 0.5) +
             guides(fill = guide_legend(title="Cluster"))
   
}

grid.arrange(grobs = p,
             ncol = 2)

```

### Cluster membership
Use of the fuzzy-c-means clustering algorithm results in every sample having a membership coefficient for each cluster. These membership coefficients range from zero to one, with one being the highest degree of membership. These membership can be plotted to help visualise the "fuzzy" nature of the clustering:

```{r membership-fig, fig.cap = "Membership coefficients for the nine clusters plotted for the first two PCs. Blue symbols have low membership (~0), whilst red symbols have high membership (~1).", out.width='100%', fig.align='center', fig.asp=2, cache = TRUE, message = FALSE, warning = FALSE}
#Extract the membership coefficients
members <- data.frame(fcm$membership, check.names = FALSE)

#Reorder the columns based on the new cluster order defined above
members <- members[dim1_mean$CLUSTER]
names(members) <- paste0("Membership.", 1:ncol(members))

#Join clusters and members
members <- data.frame(clusters,
                      members)

#Create and empty list for the plots
p <- list()

#Populate each item in the list using the dimension defined
#in x and y
for (i in 1:9) {
   
   p[[i]] <- ggplot(data = members) +
             geom_point(aes_string(x = "Dim.1",
                                   y = "Dim.2",
                                   fill = paste0("Membership.",
                                                 i)),
                        shape = 21,
                        size = 3,
                        alpha = 0.5) +
             ggtitle(paste("Cluster", i)) +
             theme(legend.position = "None") +
             scale_fill_gradient(low = "blue",
                                 high = "red")
   
}

grid.arrange(grobs = p,
             ncol = 3)

```

Figures \@ref(fig:cluster-fig) and \@ref(fig:membership-fig) illustrate how the soil XRPD data in this data set reflect to soil mineral continuum, and as such can be challenging to cluster into a small number of group. In particular the membership coefficients in Figure \@ref(fig:membership-fig) help highlight how soils can exist on the boundary of two or more clusters and therefore have similar membership coefficients to numerous clusters. This property is characteristic of most large soil data sets, and can make it challenging to define very distinct clusters. However, the membership coefficient data can be used so that only samples with the highest coefficients are retained, resulting in more distinct mineralogical groups that do no overlap.

### Subsetting Clusters
Here, more mineralogically distinct clusters will be created by only retaining samples within each cluster that have a membership coefficient exceeding the 75^th^ percentile:

```{r, fig.cap = "The formation of distinct clusters by retaining the samples within each cluster that have membership coefficients greater than the 75% percentile.", out.width='100%', fig.align='center', fig.asp=1.5, cache = TRUE, message = FALSE, warning = FALSE}
#Creat a blank name to populate with the unique SSNs
member_ssn <- list()

#A loop to omit samples from each cluster with low membership coefficient
for (i in 1:9) {
  
  memberships <- members[which(members$NEW_CLUSTER == i), c("SSN",
                                                            paste0("Membership.", i))]

  
  #Extract the samples with top 25 % of membership coefficient for each cluster
  memberships_75 <- which(memberships[[2]] > quantile(memberships[[2]],
                                                      probs = 0.75))
  
  member_ssn[[i]] <- memberships$SSN[memberships_75]
  
  names(member_ssn)[i] <- paste0("Cluster.", i)
  
}

#Unlist the indexes
member_ssn <- unname(unlist(member_ssn))

members_sub <- members[which(members$SSN %in% member_ssn),]

#Plot the results
#Create and empty list
p <- list()

#Populate each item in the list using the dimension defined
#in x and y
for (i in 1:length(x)) {
   
   p[[i]] <- ggplot(data = members_sub) +
             geom_point(aes_string(x = paste0("Dim.", x[i]),
                                   y = paste0("Dim.", y[i]),
                                   fill = "NEW_CLUSTER"),
                        shape = 21,
                        size = 3,
                        alpha = 0.5) +
             guides(fill = guide_legend(title="Cluster"))
   
}

grid.arrange(grobs = p,
             ncol = 2)
```

## Exploring results
Now that a set of mineralogically distinct clusters have been defined from the data, there are number of ways that the data can be explored and interpreted. Firstly, since these data are geo-referenced, the spatial distribution of each cluster can be visualised:

```{r, fig.cap = "Interactive map of the soil samples associated with Cluster 9.", out.width='80%', fig.align='center', message=FALSE, warning=FALSE, cache = TRUE}
clust_sub <- join(members_sub[c("SSN", "NEW_CLUSTER")],
                  props, by = "SSN") 

#Plot cluster 9
leaflet(clust_sub[which(clust_sub$NEW_CLUSTER == 9), ]) %>% 
  addTiles() %>%
  addCircleMarkers(~Longitude, ~Latitude)
```

Furthermore, the XRPD data of each cluster can be visualised, illustrating that even though samples within each cluster are dispersed across sub-Saharan Africa, their XRPD signals (and, hence mineralogies) are very similar, which can readily be plotted with a little manipulation of the data:

```{r, fig.cap = "Clustered pre-treated XRPD from Cluster 9.", out.width='100%', fig.align='center', fig.asp=0.75, cache = TRUE, message = FALSE, warning = FALSE}
#Create a blank list to populate
cluster_xrpd <- list()

for (i in 1:9) {
cluster_xrpd[[i]] <- xrpd_aligned[clust_sub$SSN[clust_sub$NEW_CLUSTER == i]]
names(cluster_xrpd)[i] <- paste0("Cluster.", i)
}

#Plot cluster 9
plot(as_multi_xy(cluster_xrpd$Cluster.9), wavelength = "Cu", normalise = TRUE)
```

Given that the soil mineral composition ultimately governs the total concentrations of nutrients and their phyto-availability, there nine mineralogically different clusters should display contrasting geochemical properties. These geochemical properties are present in the `props` data already loaded, and the cluster factor can be added to these data:

```{r, cache = TRUE, message = FALSE, warning = FALSE}
#Join clust_sub to props
props_sub <- join(clust_sub[c("SSN", "NEW_CLUSTER")],
                  props,
                  by = "SSN")

#Rename the clusters to C1... C9
props_sub$NEW_CLUSTER <- paste0("C", props_sub$NEW_CLUSTER)

#Subset the data to the variables of interest
total_nutrients <- subset(props_sub,
                          select = c(NEW_CLUSTER,
                                     TOC, K, Ca,
                                     Mn, Fe, Ni,
                                     Cu, Zn))
```

After which, the relative enrichments and deficiencies of each cluster for these total nutrient concentrations can be visualised using barplots:

```{r, fig.cap = "Average total nutrient concentrations of each cluster expressed as deviation in log-ratio scale from the geometric mean. Values below zero represent average concentrations lower than that for the entire dataset, whilst values above zero represent the opposite.", out.width='100%', fig.align='center', fig.asp=0.75,cache = TRUE, message = FALSE, warning = FALSE}
#Create geometric mean function
gmean <- function(x) {exp(mean(log(x)))}

#Compute overall geometric means for each nutrient (i.e. column)
total_nutrients_gmeans <- apply(total_nutrients[-1], 2, gmean) 

#Compute the geometric mean for each nutrient by cluster
cluster_gmeans <- by(total_nutrients[-1],
                     as.factor(total_nutrients$NEW_CLUSTER),
                     function(x) apply(x, 2, gmean))

#Bind the data by row
cluster_gmeans <- do.call(rbind, cluster_gmeans)

#Calculate log-ratios by dividing by the geometric mean
#of each nutrient
bp <- apply(cluster_gmeans,1,
            function(x) log(x/total_nutrients_gmeans))


#Use melt from the reshape2 package so that the data are
#in the right format for ggplot2:
bpm <- melt(bp)

#Create a barplot using ggplot2
g1 <- ggplot(bpm,
             aes(fill=Var1, y=value, x=Var2)) +
      geom_bar(position="dodge", stat="identity") +
      theme(legend.title = element_blank()) +
      xlab("Cluster") +
      ylab("")

#Make the barplot interactive
ggplotly(g1)
```

The resulting barplot illustrates how the nine clusters defined by the XRPD data are characterised by contrasting geochemical compositions. Clusters 8 and 9 are by far the most deficient in all nutrients, whilst Clusters 1, 2 and 3 are enriched in all nutrients (with the exception of K in Cluster 1). Interestingly, soils in Cluster 6 have the highest concentrations of total K on average, but are generally deficient in other nutrients. The relationships between the geochemical compositions of each cluster and the mineralogy can be interpreted by quantifying the mean diffractogram of each cluster using the full pattern summation functions outlined in Chapter \@ref(quant):

```{r, fig.cap = "The mean diffractogram of Cluster 9.", out.width='100%', fig.align='center', fig.asp=0.75, cache = TRUE, message = FALSE, warning = FALSE}
#Create a blank list to be populated
xrpd_clusters <- list()

#Calculate the mean diffractogram of each cluster
for (i in 1:9) {
  
  #Extract the SSN for the cluster
  ssns <- clust_sub$SSN[which(clust_sub$NEW_CLUSTER == i)]
  
  #Extract the aligned xrpd data and make sure it is a multiXY object
  xrpd_clusters[[i]] <- as_multi_xy(xrpd_aligned[ssns])
  
  names(xrpd_clusters)[i] <- paste0("Cluster.", i)
  
  #Convert to a data frame
  xrpd_clusters[[i]] <- multi_xy_to_df(xrpd_clusters[[i]],
                                       tth = TRUE)
  
  #Calculate mean diffractogram
  xrpd_clusters[[i]] <- as_xy(data.frame("tth" = xrpd_clusters[[i]]$tth,
                                         "counts" = rowMeans(xrpd_clusters[[i]][-1])))
  
}

#Plot the mean diffractogram of Cluster 9
plot(xrpd_clusters$Cluster.9, wavelength = "Cu")
```

Now that the mean diffractogram of each cluster has been computed. The mineralogy of each diffractogram can be quantified [using `afps()`](#afps) using the`rockjock_afsis` library created above, yielding an approximate average of the mineral composition of each cluster:

```{r, cache = TRUE, message = FALSE, warning = FALSE, results= 'hide'}
#Define the names of the minerals to supply to afps
usuals <- c("Quartz", "Kaolinite",
            "Halloysite", "Dickite",
            "Smectite (Di)", "Smectite (ML)",
            "Illite", "Mica (Di)", "Muscovite",
            "K-feldspar", "Plagioclase",
            "Goethite", "Maghemite", "Ilmenite",
            "Hematite", "Gibbsite", "Magnetite",
            "Anatase", "Amphibole", "Pyroxene",
            "Calcite", "Gypsum", "Organic matter",
            "HUMIC_ACID", "FERRIHYDRITE_HUMBUG_CREEK",
            "FERRIHYDRITE",
            "BACK_POS")

#Define the amorphous phases
amorph <- c("ORGANIC_MATTER", "ORGANIC_AFSIS",
            "HUMIC_ACID", "FERRIHYDRITE_HUMBUG_CREEK",
            "FERRIHYDRITE")

clusters_quant <- multi_fit <- lapply(xrpd_clusters, afps,
                                      lib = rockjock_afsis,
                                      std = "QUARTZ_1_AFSIS",
                                      refs = usuals,
                                      amorphous = amorph,
                                      align = 0.2,
                                      lod = 0.05,
                                      amorphous_lod = 0,
                                      force = "BACK_POS")

#Load the regrouping structures for rockjock and afsis
data(rockjock_regroup)
data(afsis_regroup)

#lapply the regrouping structure
clusters_quant_rg <- lapply(clusters_quant,
                            regroup,
                            y = rbind(rockjock_regroup[1:2],
                                      afsis_regroup[1:2]))

#Extract the quantitative data
quant_table <- summarise_mineralogy(clusters_quant_rg,
                                    type = "grouped",
                                    order = TRUE)

#Reduce to the 10 most common phases for a barplot
quant_table <- quant_table[2:11]
```

The resulting quantification can then be plotted:

```{r, fig.cap = "Mineral compositions of the nine clusters based on the mean diffractogram", out.width='100%', fig.align='center', fig.asp=0.75, cache = TRUE, message = FALSE, warning = FALSE}
#Rename clusters C1 to C9
rownames(quant_table) <- paste0("C", rownames(quant_table))

#Use melt from the reshape2 package so that the data are
#in the right format for ggplot2:
quant_table_m <- melt(as.matrix(quant_table))

#Create a barplot using ggplot2
g2 <- ggplot(quant_table_m,
             aes(fill=Var2, y=value, x=Var1)) +
      geom_bar(position="dodge", stat="identity") +
      theme(legend.title = element_blank()) +
      xlab("Cluster") +
      ylab("")

#Make the barplot interactive
ggplotly(g2)
```

